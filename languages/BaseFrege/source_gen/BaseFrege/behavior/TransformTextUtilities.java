package BaseFrege.behavior;

/*Generated by MPS */

import java.util.List;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.scope.Scope;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class TransformTextUtilities {
  private String unmatchableFallback = "illegal pattern";

  public void setUnmatchableFallback(String unmatchableFallback) {
    this.unmatchableFallback = unmatchableFallback;
  }


  private Trie illegalPatterns;

  public void setIllegalPatterns(List<String> illegalPatterns) {
    this.illegalPatterns = new Trie(illegalPatterns);
  }


  public static boolean isComposedFrom(String pattern, List<Character> combinableSymbols) {
    Set<Character> checker = SetSequence.fromSet(new HashSet<Character>());
    for (char character : combinableSymbols) {
      SetSequence.fromSet(checker).addElement(character);
    }

    for (int i = 0; i < pattern.length(); i++) {
      if (!(SetSequence.fromSet(checker).contains(pattern.charAt(i)))) {
        return false;
      }
    }
    return true;
  }


  public static String getShortest(List<String> words) {
    if (ListSequence.fromList(words).count() <= 0) {
      return "";
    }

    String shortest = ListSequence.fromList(words).first();
    for (String word : words) {
      if (word.length() < shortest.length()) {
        shortest = word;
      }
    }
    return shortest;
  }


  public String getCombinableText(String currentlyEnteredPattern, List<Character> combinableSymbols) {
    // Method used in "text" part of transformation menus 
    // Consider e.g. combinable symbols . and ! 
    // You may want to apply a transformation once user writes any word using those symbols (e.g. ".!!", "!...", etc.) 
    // There is a small problem: the word the user writes must not begin with ".." or "!!." 
    // This method returns entered pattern if and only if it is considered valid, e.g.: 
    //  "." - returns e.g. ".:", i.e. something valid, but not what user wrote (but may write) 
    //  ".!" - returns ".!", since this is a legal pattern 
    //  ".." - returns "illegal pattern", since it cannot become valid once it already begins with an exception 

    // Check if the provided pattern is composable from the given symbols 
    if (!(isComposedFrom(currentlyEnteredPattern, combinableSymbols))) {
      return this.unmatchableFallback;
    }

    // Check if the provided pattern has a match among the exceptions 
    boolean isMatch = this.illegalPatterns.containsPrefix(currentlyEnteredPattern);
    if (isMatch) {
      boolean isExactMatch = this.illegalPatterns.containsWord(currentlyEnteredPattern);
      if (isExactMatch) {
        // Exact match - the current pattern cannot be used and will not be usable 
        return this.unmatchableFallback;
      } else {
        // Partial match - the current pattern may lead to an exception 
        // Return therefore any valid pattern with the same prefix as is the currently entered text 
        List<String> validPatterns = this.illegalPatterns.reverseReach(currentlyEnteredPattern, combinableSymbols);
        if (ListSequence.fromList(validPatterns).isNotEmpty()) {
          return getShortest(validPatterns);
        }
      }
    } else {
      // No match - the current pattern is completely valid and may be used 
      return currentlyEnteredPattern;
    }

    // Unknown error 
    return this.unmatchableFallback;
  }


  private Trie availablePatterns;

  public void setAvailablePatterns(List<String> availablePatterns) {
    this.availablePatterns = new Trie(availablePatterns);
  }


  public String getAvailablePattern(String currentlyEnteredPattern) {
    // Method used in "text" part of transformation menus 
    // Consider e.g. words 'aa', 'bb' and 'aba', which all should lead to the same transformation menu 
    // This method returns one of the available words with the same prefix as is the currently entered text, e.g.: 
    //  "a" - returns e.g. "aa" 
    //  "ab" - returns "aba" 
    //  "c" - returns "illegal pattern", since it is not a prefix to any of the defined words 
    String valid = this.availablePatterns.findShortestWord(currentlyEnteredPattern);
    if (valid != null && (valid != null && valid.length() > 0)) {
      return valid;
    }

    // Error - word with the entered prefix not found 
    return this.unmatchableFallback;
  }


  public static List<String> getStringList(Scope scope, NameResolver nameResolver) {
    List<String> result = ListSequence.fromList(new ArrayList<String>());
    Iterable<SNode> nodeList = scope.getAvailableElements(null);
    for (SNode node : Sequence.fromIterable(nodeList)) {
      // Not working for some reason...? 
      ListSequence.fromList(result).addElement(nameResolver.getName(node));
    }

    return result;
  }


  public String getNextAvailablePattern(String currentlyEnteredPattern) {
    // This method returns one of the available pattern that has the same prefix (but is not the same) 
    // as currently entered text, e.g.: 
    // Consider available words 'aa', 'aaa' and 'aba', then for entered text: 
    //  "a" - returns e.g. "aa" 
    //  "aa" - returns "aaa" 
    //  "aba" - returns "illegal pattern", since there is no other pattern with the same prefix, than 'aba' 
    List<String> availablePatterns = this.availablePatterns.reachAllWords(currentlyEnteredPattern);

    List<String> usablePatterns = ListSequence.fromList(new ArrayList<String>());
    for (String ap : availablePatterns) {
      if (!(ap.equals(currentlyEnteredPattern))) {
        ListSequence.fromList(usablePatterns).addElement(ap);
      }
    }

    String valid = getShortest(usablePatterns);
    if (valid != null && (valid != null && valid.length() > 0)) {
      return valid;
    }

    // Error - no results 
    return this.unmatchableFallback;
  }
}
