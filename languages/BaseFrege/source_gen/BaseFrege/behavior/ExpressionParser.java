package BaseFrege.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public abstract class ExpressionParser {
  private static final String rightAssociativity = "r";
  private static final String leftAssociativity = "l";
  private static final String noAssociativity = "";

  private SNode expression;
  private List<SNode> linearizedExpression;
  private boolean isInitialized;

  public ExpressionParser(SNode expression) {
    this.expression = expression;
    this.linearizedExpression = ListSequence.fromList(new ArrayList<SNode>());
    this.isInitialized = false;
    this.isParsed = false;
  }

  private boolean isStable() {
    if (ListSequence.fromList(linearizedExpression).isEmpty()) {
      if ((SLinkOperations.getTarget(expression, MetaAdapterFactory.getContainmentLink(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL, 0x4b2fbc03f0227359L, 0x4b2fbc03f022735aL, "firstTopExpression")) == null)) {
        return false;
      }
      for (SNode part : ListSequence.fromList(SLinkOperations.getChildren(expression, MetaAdapterFactory.getContainmentLink(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL, 0x4b2fbc03f0227359L, 0x4b2fbc03f022735cL, "additionalParts")))) {
        if ((SLinkOperations.getTarget(part, MetaAdapterFactory.getContainmentLink(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL, 0x4b2fbc03f022735fL, 0x4b2fbc03f0227362L, "operator")) == null) || (SLinkOperations.getTarget(part, MetaAdapterFactory.getContainmentLink(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL, 0x4b2fbc03f022735fL, 0x4b2fbc03f0227360L, "topExpression")) == null)) {
          return false;
        }
      }
    }

    return true;
  }

  private void simplify() {
    ListSequence.fromList(linearizedExpression).clear();
    ListSequence.fromList(linearizedExpression).addElement(SLinkOperations.getTarget(expression, MetaAdapterFactory.getContainmentLink(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL, 0x4b2fbc03f0227359L, 0x4b2fbc03f022735aL, "firstTopExpression")));
    for (SNode part : ListSequence.fromList(SLinkOperations.getChildren(expression, MetaAdapterFactory.getContainmentLink(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL, 0x4b2fbc03f0227359L, 0x4b2fbc03f022735cL, "additionalParts")))) {
      ListSequence.fromList(linearizedExpression).addElement(SLinkOperations.getTarget(part, MetaAdapterFactory.getContainmentLink(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL, 0x4b2fbc03f022735fL, 0x4b2fbc03f0227362L, "operator")));
      ListSequence.fromList(linearizedExpression).addElement(SLinkOperations.getTarget(part, MetaAdapterFactory.getContainmentLink(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL, 0x4b2fbc03f022735fL, 0x4b2fbc03f0227360L, "topExpression")));
    }
  }

  public void initialize() {
    // Simplify the structure into a single array while checking whether it is even worth it to type-check 
    if (!(isInitialized)) {
      if (!(isStable())) {
        return;
      }
      simplify();
    }
    isInitialized = true;
  }


  private List<SNode> postponedItems;
  private List<SNode> itemsToEvaluate;
  public SNode parsedExpression;
  public boolean isParsed;

  private void evaluateStackedItems() {
    // Ensure that the first node is always of the type EPNode 
    SNode parsedExpressionNode = EPNode__BehaviorDescriptor.getOperand_id58hJgqtY$2A.invoke(SNodeOperations.asSConcept(MetaAdapterFactory.getConcept(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL, 0x5211bd069df9eb73L, "BaseFrege.structure.EPNode")), ListSequence.fromList(itemsToEvaluate).last());

    // Evaluate the items in the secondary stack from right to left 
    for (int i = ListSequence.fromList(itemsToEvaluate).count() - 2; i > 0; i -= 2) {
      SNode operator = ListSequence.fromList(itemsToEvaluate).getElement(i);
      SNode secondOperand = ListSequence.fromList(itemsToEvaluate).getElement(i - 1);
      parsedExpressionNode = EPNode__BehaviorDescriptor.getSubtree_id58hJgqtYykv.invoke(SNodeOperations.asSConcept(MetaAdapterFactory.getConcept(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL, 0x5211bd069df9eb73L, "BaseFrege.structure.EPNode")), parsedExpressionNode, SNodeOperations.cast(operator, MetaAdapterFactory.getConcept(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL, 0x4b2fbc03f0258a57L, "BaseFrege.structure.OperatorReference")), secondOperand);
    }

    // Clear, so that only the result remains in the secondary stack 
    ListSequence.fromList(itemsToEvaluate).clear();
    ListSequence.fromList(itemsToEvaluate).addElement(parsedExpressionNode);
  }

  private void handlePostponedItems(int upToPrecedence) {
    // Set a secondary stack to hold the items that may not be evaluated immediately (due to left-assoc. operators) 
    itemsToEvaluate = ListSequence.fromList(new ArrayList<SNode>());

    // Set the data to compare against the latest found operator 
    int lastPrecedence = -1;
    String lastAssociativity = "";

    // Iterate the postponed items until empty or the operator with the same precedence is found 
    while (ListSequence.fromList(postponedItems).isNotEmpty()) {
      SNode item = ListSequence.fromList(postponedItems).removeLastElement();

      // Is an operator? 
      if (SNodeOperations.isInstanceOf(item, MetaAdapterFactory.getConcept(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL, 0x4b2fbc03f0258a57L, "BaseFrege.structure.OperatorReference"))) {
        SNode operator = SNodeOperations.cast(item, MetaAdapterFactory.getConcept(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL, 0x4b2fbc03f0258a57L, "BaseFrege.structure.OperatorReference"));
        SNode fixity = OperatorReference__BehaviorDescriptor.getFixity_id69o01iEpsqt.invoke(operator);

        if ((int) Fixity__BehaviorDescriptor.getPrecedence_id69o01iEq2ny.invoke(fixity) <= upToPrecedence) {
          // Case 1: We have struck an operator with the same or smaller precedence, so we are finished here 
          // Put back the removed operator back to the stack and continue with the parsing process 
          ListSequence.fromList(postponedItems).addElement(item);
          break;
        } else if (((int) Fixity__BehaviorDescriptor.getPrecedence_id69o01iEq2ny.invoke(fixity) == lastPrecedence) && (!(Fixity__BehaviorDescriptor.getAssociativity_id69o01iEpW_D.invoke(fixity).equals(lastAssociativity)))) {
          // Case 2: There are several operators with the same precedence, but different associativity 
          evaluateDifferentAssociativities();
        } else if (((int) Fixity__BehaviorDescriptor.getPrecedence_id69o01iEq2ny.invoke(fixity) == lastPrecedence) && (Fixity__BehaviorDescriptor.getAssociativity_id69o01iEpW_D.invoke(fixity).equals(noAssociativity))) {
          // Case 3: Several non-associative operators found on the same level 
          evaluateSeveralInfixOperators();
        } else if ((int) Fixity__BehaviorDescriptor.getPrecedence_id69o01iEq2ny.invoke(fixity) == lastPrecedence) {
          // Case 4: Operator with the same precedence and associativity as the last one found 
          if (Fixity__BehaviorDescriptor.getAssociativity_id69o01iEpW_D.invoke(fixity).equals(rightAssociativity)) {
            // Case 4.1: Right-associative operator 
            if (ListSequence.fromList(itemsToEvaluate).count() >= 3) {
              evaluateStackedItems();
            }
          } else {
            // Case 4.2: Left-associative operator 
            // The operator is added to the secondary stack and will be handled once a new operator is struck 
          }
        } else {
          // Case 5: New operator found different from the last one 
          if (ListSequence.fromList(itemsToEvaluate).count() >= 3) {
            evaluateStackedItems();
          }
        }

        // Set the latest precedence and associativity 
        lastPrecedence = (int) Fixity__BehaviorDescriptor.getPrecedence_id69o01iEq2ny.invoke(fixity);
        lastAssociativity = Fixity__BehaviorDescriptor.getAssociativity_id69o01iEpW_D.invoke(fixity);
      }

      // Save the current item 
      ListSequence.fromList(itemsToEvaluate).addElement(item);
    }

    // Evaluate the stacked items again, leaving the last item in the secondary stack 
    evaluateStackedItems();

    // Move the item back to the first stack 
    assert ListSequence.fromList(itemsToEvaluate).count() == 1;
    ListSequence.fromList(postponedItems).addElement(ListSequence.fromList(itemsToEvaluate).removeLastElement());
  }

  public void parse() {
    // Null the result 
    parsedExpression = null;

    // Does the expression contain at least 1 operator? 
    if (!(isInitialized) || ListSequence.fromList(linearizedExpression).count() < 3) {
      parsedExpression = EPNode__BehaviorDescriptor.getOperand_id58hJgqtY$2A.invoke(SNodeOperations.asSConcept(MetaAdapterFactory.getConcept(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL, 0x5211bd069df9eb73L, "BaseFrege.structure.EPNode")), ListSequence.fromList(linearizedExpression).first());
      isParsed = true;
      return;
    }

    // Derivation of the algorithm for transforming infix expressions to postfix 
    postponedItems = ListSequence.fromList(new ArrayList<SNode>());
    int lastPrecedence = -1;

    for (int i = 0; i < ListSequence.fromList(linearizedExpression).count(); i++) {
      SNode item = ListSequence.fromList(linearizedExpression).getElement(i);
      if (SNodeOperations.isInstanceOf(item, MetaAdapterFactory.getConcept(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL, 0x4b2fbc03f0258a57L, "BaseFrege.structure.OperatorReference"))) {
        // Operator 
        SNode operator = SNodeOperations.cast(item, MetaAdapterFactory.getConcept(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL, 0x4b2fbc03f0258a57L, "BaseFrege.structure.OperatorReference"));

        SNode fixity = OperatorReference__BehaviorDescriptor.getFixity_id69o01iEpsqt.invoke(operator);
        if ((int) Fixity__BehaviorDescriptor.getPrecedence_id69o01iEq2ny.invoke(fixity) < lastPrecedence) {
          if (ListSequence.fromList(postponedItems).count() > 1) {
            handlePostponedItems((int) Fixity__BehaviorDescriptor.getPrecedence_id69o01iEq2ny.invoke(fixity));
          }
        }

        // Update the info about the latest found operator 
        lastPrecedence = (int) Fixity__BehaviorDescriptor.getPrecedence_id69o01iEq2ny.invoke(fixity);
      }

      // Add the item to the stack 
      ListSequence.fromList(postponedItems).addElement(item);
    }

    // Handle the postponed items again 
    handlePostponedItems(-1);

    // Store the result 
    assert ListSequence.fromList(postponedItems).count() == 1;
    parsedExpression = SNodeOperations.cast(ListSequence.fromList(postponedItems).removeElementAt(0), MetaAdapterFactory.getConcept(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL, 0x5211bd069df9eb73L, "BaseFrege.structure.EPNode"));
    isParsed = true;
  }

  protected abstract void evaluateDifferentAssociativities();
  protected abstract void evaluateSeveralInfixOperators();
}
