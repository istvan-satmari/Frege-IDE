package BaseFrege.behavior;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.util.Iterator;

public class Trie {
  private class Layer {
    private Map<Character, Trie.Layer> nextLayers = MapSequence.fromMap(new HashMap<Character, Trie.Layer>());
    private boolean terminal = false;

    public Trie.Layer move(char character) {
      return MapSequence.fromMap(this.nextLayers).get(character);
    }

    public Trie.Layer find(String word) {
      Trie.Layer currentLayer = this;
      for (int i = 0; i < word.length(); i++) {
        char currentCharacter = word.charAt(i);
        if (MapSequence.fromMap(currentLayer.nextLayers).containsKey(currentCharacter)) {
          currentLayer = MapSequence.fromMap(currentLayer.nextLayers).get(currentCharacter);
        } else {
          return null;
        }
      }

      return currentLayer;
    }

    public boolean contains(String word) {
      Trie.Layer l = this.find(word);
      if (l != null) {
        return l.terminal;
      }

      return false;
    }

    public boolean containsPrefix(String word) {
      return this.find(word) != null;
    }

    public void add(String word) {
      if (word == null || (word == null || word.length() == 0)) {
        return;
      }

      Trie.Layer currentLayer = this;
      for (int i = 0; i < word.length(); i++) {
        char currentCharacter = word.charAt(i);
        if (!(MapSequence.fromMap(currentLayer.nextLayers).containsKey(currentCharacter))) {
          MapSequence.fromMap(currentLayer.nextLayers).put(currentCharacter, new Trie.Layer());
        }

        currentLayer = MapSequence.fromMap(currentLayer.nextLayers).get(currentCharacter);
      }

      currentLayer.terminal = true;
    }

    public boolean isLeaf() {
      return MapSequence.fromMap(this.nextLayers).isEmpty();
    }

    public List<Character> getMovers() {
      final List<Character> movers = ListSequence.fromList(new ArrayList<Character>());
      SetSequence.fromSet(MapSequence.fromMap(this.nextLayers).keySet()).visitAll(new IVisitor<Character>() {
        public void visit(Character it) {
          ListSequence.fromList(movers).addElement(it);
        }
      });
      return movers;
    }

    public boolean containsMover(char mover) {
      return MapSequence.fromMap(this.nextLayers).containsKey(mover);
    }

    private List<String> reachAll(final boolean bottomsOnly) {
      if (this.isLeaf()) {
        return ListSequence.fromListAndArray(new ArrayList<String>(), "");
      }

      final List<String> allWords = ListSequence.fromList(new ArrayList<String>());
      SetSequence.fromSet(MapSequence.fromMap(this.nextLayers).keySet()).visitAll(new IVisitor<Character>() {
        public void visit(Character it) {
          List<String> words = MapSequence.fromMap(Layer.this.nextLayers).get(it).reachAll(bottomsOnly);

          for (String word : words) {
            ListSequence.fromList(allWords).addElement(it + word);
          }
        }
      });

      if (this.terminal && !(bottomsOnly)) {
        ListSequence.fromList(allWords).addElement("");
      }

      return allWords;
    }

    public List<String> reachAllWords() {
      return this.reachAll(false);
    }

    public List<String> reachAllBottoms() {
      return this.reachAll(true);
    }
  }

  private Trie.Layer root;

  public Trie() {
    this.root = new Trie.Layer();
    this.root.terminal = true;
  }

  public Trie(List<String> words) {
    this();
    this.addWords(words);
  }

  public boolean containsPrefix(String prefix) {
    return this.root.containsPrefix(prefix);
  }

  public boolean containsWord(String word) {
    return this.root.contains(word);
  }

  public void addWord(String word) {
    this.root.add(word);
  }

  public void addWords(List<String> words) {
    for (String word : words) {
      this.root.add(word);
    }
  }

  public List<String> reachAllWords(String prefix) {
    if (prefix == null) {
      prefix = "";
    }

    List<String> result = ListSequence.fromList(new ArrayList<String>());
    Trie.Layer l = this.root.find(prefix);
    if (l != null) {
      List<String> words = l.reachAllWords();
      for (String word : words) {
        ListSequence.fromList(result).addElement(prefix + word);
      }
    }

    return result;
  }

  public List<String> reachAllBottoms(String prefix) {
    if (prefix == null) {
      prefix = "";
    }

    List<String> result = ListSequence.fromList(new ArrayList<String>());
    Trie.Layer l = this.root.find(prefix);
    if (l != null) {
      List<String> words = l.reachAllBottoms();
      for (String word : words) {
        ListSequence.fromList(result).addElement(prefix + word);
      }
    }

    return result;
  }

  public String findShortestWord(String prefix) {
    if (prefix == null) {
      prefix = "";
    }

    List<String> words = this.reachAllWords(prefix);
    if (ListSequence.fromList(words).count() <= 0) {
      return null;
    }

    String shortest = ListSequence.fromList(words).getElement(0);
    for (String word : words) {
      if (word.length() < shortest.length()) {
        shortest = word;
      }
    }
    return shortest;
  }

  public String findLongestWord(String prefix) {
    if (prefix == null) {
      prefix = "";
    }

    List<String> words = this.reachAllBottoms(prefix);
    if (ListSequence.fromList(words).count() <= 0) {
      return null;
    }

    String longest = ListSequence.fromList(words).getElement(0);
    for (String word : words) {
      if (word.length() > longest.length()) {
        longest = word;
      }
    }
    return longest;
  }

  private List<String> reverseReachSublayer(Trie.Layer sublayer, List<Character> unreachableMovers) {
    List<String> result = ListSequence.fromList(new ArrayList<String>());
    for (char um : unreachableMovers) {
      if (sublayer.containsMover(um)) {
        List<String> unreachables = this.reverseReachSublayer(sublayer.move(um), unreachableMovers);
        {
          Iterator<String> unreachable_it = ListSequence.fromList(unreachables).iterator();
          String unreachable_var;
          while (unreachable_it.hasNext()) {
            unreachable_var = unreachable_it.next();
            ListSequence.fromList(result).addElement(um + unreachable_var);
          }
        }
      } else {
        ListSequence.fromList(result).addElement(new String(new char[]{um}));
      }
    }

    return result;
  }

  public List<String> reverseReach(String prefix, List<Character> unreachableMovers) {
    if (prefix == null) {
      prefix = "";
    }

    Trie.Layer l = this.root.find(prefix);
    if (l != null) {
      return this.reverseReachSublayer(this.root, unreachableMovers);
    }

    return null;
  }
}
