package BaseFrege.structure;

/*Generated by MPS */

import jetbrains.mps.lang.smodel.LanguageConceptIndex;
import jetbrains.mps.lang.smodel.LanguageConceptIndexBuilder;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import org.jetbrains.mps.openapi.language.SAbstractConcept;

public final class LanguageConceptSwitch {
  private final LanguageConceptIndex myIndex;
  public static final int AIOperator = 0;
  public static final int AIVariable = 1;
  public static final int Annotation = 2;
  public static final int AnnotationItem = 3;
  public static final int ApplicationEntity = 4;
  public static final int BCContent = 5;
  public static final int BCLine = 6;
  public static final int BCNestedComment = 7;
  public static final int BinExPart = 8;
  public static final int BinaryExpressions = 9;
  public static final int BlockComment = 10;
  public static final int BoolTypeNode = 11;
  public static final int BooleanValue = 12;
  public static final int BracketsApplication = 13;
  public static final int CPExprToExpr = 14;
  public static final int CPExprToGuards = 15;
  public static final int Case = 16;
  public static final int CasePart = 17;
  public static final int CharTypeNode = 18;
  public static final int CharValue = 19;
  public static final int Comment = 20;
  public static final int ConstructorApplication = 21;
  public static final int ConstructorReference = 22;
  public static final int CoreBoolType = 23;
  public static final int CoreCharType = 24;
  public static final int CoreDoubleType = 25;
  public static final int CoreIntType = 26;
  public static final int CoreStringType = 27;
  public static final int CoreType = 28;
  public static final int DCScopeProvider = 29;
  public static final int Data = 30;
  public static final int DataConstructor = 31;
  public static final int Definition = 32;
  public static final int DoubleTypeNode = 33;
  public static final int DoubleValue = 34;
  public static final int EPBinaryExpression = 35;
  public static final int EPFinalOperand = 36;
  public static final int EPNode = 37;
  public static final int EmptyExpression = 38;
  public static final int EmptyLine = 39;
  public static final int Expression = 40;
  public static final int FDA = 41;
  public static final int FDABracket = 42;
  public static final int FDAVarName = 43;
  public static final int FDAVarWildcard = 44;
  public static final int FDAVariable = 45;
  public static final int FDAssignment = 46;
  public static final int FDComplete = 47;
  public static final int FDGCEName = 48;
  public static final int FDGCEOperator = 49;
  public static final int FDGCommonEntity = 50;
  public static final int FDGGuards = 51;
  public static final int FDGrouped = 52;
  public static final int FDGuards = 53;
  public static final int FalseValue = 54;
  public static final int Fixity = 55;
  public static final int FullType = 56;
  public static final int FunctionApplication = 57;
  public static final int FunctionDefinition = 58;
  public static final int FunctionTypeNode = 59;
  public static final int GenericApplication = 60;
  public static final int Guard = 61;
  public static final int IIConstructor = 62;
  public static final int IIFunction = 63;
  public static final int IIOperator = 64;
  public static final int IITCLAll = 65;
  public static final int IITCLConstructor = 66;
  public static final int IITCLItem = 67;
  public static final int IITConstructorList = 68;
  public static final int IIType = 69;
  public static final int IfThenElse = 70;
  public static final int ImplicitDefinition = 71;
  public static final int Import = 72;
  public static final int ImportAs = 73;
  public static final int ImportHiding = 74;
  public static final int ImportItem = 75;
  public static final int ImportItems = 76;
  public static final int ImportReference = 77;
  public static final int ImportedEntityApplication = 78;
  public static final int ImportedTypeReferenceUsage = 79;
  public static final int IncompleteCommand = 80;
  public static final int Infix = 81;
  public static final int InfixAbstract = 82;
  public static final int Infixl = 83;
  public static final int Infixr = 84;
  public static final int IntTypeNode = 85;
  public static final int IntegerValue = 86;
  public static final int LCQArrowAssignment = 87;
  public static final int LCQGuard = 88;
  public static final int LCQLet = 89;
  public static final int LCQualifier = 90;
  public static final int LPExpression = 91;
  public static final int LPLambda = 92;
  public static final int Lambda = 93;
  public static final int LambdaPart = 94;
  public static final int LateLoader = 95;
  public static final int Let = 96;
  public static final int LetDefinitions = 97;
  public static final int LineComment = 98;
  public static final int List = 99;
  public static final int ListComprehension = 100;
  public static final int ListEnumeration = 101;
  public static final int ListRange = 102;
  public static final int ListTypeNode = 103;
  public static final int Literal = 104;
  public static final int LocalTypeReferenceUsage = 105;
  public static final int MEFunction = 106;
  public static final int MEOperator = 107;
  public static final int MEPMImport = 108;
  public static final int MEPMReference = 109;
  public static final int MEPMSelf = 110;
  public static final int MEPModule = 111;
  public static final int METCLAll = 112;
  public static final int METCLConstructor = 113;
  public static final int METCLItem = 114;
  public static final int METConstructorList = 115;
  public static final int METype = 116;
  public static final int Module = 117;
  public static final int ModuleExport = 118;
  public static final int ModuleName = 119;
  public static final int ModuleNameFinal = 120;
  public static final int ModuleNamePreFinal = 121;
  public static final int NegativeExpression = 122;
  public static final int NodeCONID = 123;
  public static final int NodeOperator = 124;
  public static final int NodeVARID = 125;
  public static final int OperatorApplication = 126;
  public static final int OperatorReference = 127;
  public static final int Otherwise = 128;
  public static final int PBracket = 129;
  public static final int PConstructor = 130;
  public static final int PLEBPatternArgument = 131;
  public static final int PLEBPlaceholder = 132;
  public static final int PList = 133;
  public static final int PListBracket = 134;
  public static final int PListColon = 135;
  public static final int PListVar = 136;
  public static final int PLiteral = 137;
  public static final int PTuple = 138;
  public static final int PVarName = 139;
  public static final int PVarOperator = 140;
  public static final int PVarWildcard = 141;
  public static final int PVariable = 142;
  public static final int Pattern = 143;
  public static final int PatternArgument = 144;
  public static final int PatternFunction = 145;
  public static final int PatternFunctionInGroup = 146;
  public static final int PatternOperator = 147;
  public static final int PatternOperatorInGroup = 148;
  public static final int PatternWrapper = 149;
  public static final int PrimaryExpression = 150;
  public static final int QCONID = 151;
  public static final int QVARID = 152;
  public static final int Simpletype = 153;
  public static final int Skeleton = 154;
  public static final int StringTypeNode = 155;
  public static final int StringValue = 156;
  public static final int Term = 157;
  public static final int TopExpression = 158;
  public static final int TrueValue = 159;
  public static final int Tuple = 160;
  public static final int TupleTypeNode = 161;
  public static final int Type = 162;
  public static final int TypeA = 163;
  public static final int TypeB = 164;
  public static final int TypeCarrier = 165;
  public static final int TypeFunction = 166;
  public static final int TypeList = 167;
  public static final int TypeName = 168;
  public static final int TypeReference = 169;
  public static final int TypeReferenceUsage = 170;
  public static final int TypeTuple = 171;
  public static final int TypeVariable = 172;
  public static final int TypeVariableReference = 173;
  public static final int TypeWrapper = 174;
  public static final int UnknownTypeNode = 175;
  public static final int VariableReference = 176;
  public static final int WherePart = 177;

  public LanguageConceptSwitch() {
    LanguageConceptIndexBuilder builder = new LanguageConceptIndexBuilder(0x90eaf9a4a968473cL, 0x8aedfef10c04a5dfL);
    builder.put(0x3f5c5828a3894ecaL, AIOperator);
    builder.put(0x3f5c5828a3894ebaL, AIVariable);
    builder.put(0x7fa876a53c3d8c0L, Annotation);
    builder.put(0x3f5c5828a3894eb9L, AnnotationItem);
    builder.put(0x3d75775c325a97b8L, ApplicationEntity);
    builder.put(0x100cc1cc53ffb6dcL, BCContent);
    builder.put(0x76d2ad9a0d655e2aL, BCLine);
    builder.put(0x100cc1cc53ffb707L, BCNestedComment);
    builder.put(0x4b2fbc03f022735fL, BinExPart);
    builder.put(0x4b2fbc03f0227359L, BinaryExpressions);
    builder.put(0x76d2ad9a0d655e0fL, BlockComment);
    builder.put(0x53469815341d1ff0L, BoolTypeNode);
    builder.put(0x7fa876a53c3d90cL, BooleanValue);
    builder.put(0x4b2fbc03f0235dafL, BracketsApplication);
    builder.put(0x5feee6d035b3f8a8L, CPExprToExpr);
    builder.put(0x5feee6d035b3f8d2L, CPExprToGuards);
    builder.put(0x7fa876a53c3d93bL, Case);
    builder.put(0x5feee6d035b3f879L, CasePart);
    builder.put(0x53469815341d2be3L, CharTypeNode);
    builder.put(0x7fa876a53c3d908L, CharValue);
    builder.put(0x76d2ad9a0d655de6L, Comment);
    builder.put(0x53fc7efdedebfe7dL, ConstructorApplication);
    builder.put(0x53091a40f7d3538eL, ConstructorReference);
    builder.put(0x9228a669f77f058L, CoreBoolType);
    builder.put(0x9228a669f77f039L, CoreCharType);
    builder.put(0x46dba762a640c04bL, CoreDoubleType);
    builder.put(0x9228a669f77ed97L, CoreIntType);
    builder.put(0x78ac394b5a419231L, CoreStringType);
    builder.put(0x9228a669f77f018L, CoreType);
    builder.put(0x53091a40f7add1f5L, DCScopeProvider);
    builder.put(0x7fa876a53c3d904L, Data);
    builder.put(0x608e2b4f233247d0L, DataConstructor);
    builder.put(0x7fa876a53c3d89fL, Definition);
    builder.put(0x53469815341d2be4L, DoubleTypeNode);
    builder.put(0x7fa876a53c3d90bL, DoubleValue);
    builder.put(0x5211bd069df9eb70L, EPBinaryExpression);
    builder.put(0x5211bd069df9ed7dL, EPFinalOperand);
    builder.put(0x5211bd069df9eb73L, EPNode);
    builder.put(0x6ff7dcdd48f4eaabL, EmptyExpression);
    builder.put(0x100cc1cc541493b9L, EmptyLine);
    builder.put(0x7fa876a53c3d8d7L, Expression);
    builder.put(0xc54adc878e2b2f8L, FDA);
    builder.put(0xc54adc878e2e874L, FDABracket);
    builder.put(0xc54adc878e2e87bL, FDAVarName);
    builder.put(0x26ffe1f9af84fcc3L, FDAVarWildcard);
    builder.put(0x26ffe1f9af84fcc2L, FDAVariable);
    builder.put(0x5feee6d035b3dceaL, FDAssignment);
    builder.put(0x3d7900fe84e0386eL, FDComplete);
    builder.put(0x4dbb8871591a4a35L, FDGCEName);
    builder.put(0x4dbb8871591a4a88L, FDGCEOperator);
    builder.put(0x4dbb8871591a4a34L, FDGCommonEntity);
    builder.put(0x2c5b28a4a146e49fL, FDGGuards);
    builder.put(0x155bf5aa28426de7L, FDGrouped);
    builder.put(0x5feee6d035b3dcebL, FDGuards);
    builder.put(0x1987c8739f20387fL, FalseValue);
    builder.put(0x7fa876a53c3d8c2L, Fixity);
    builder.put(0x3f5c5828a3893019L, FullType);
    builder.put(0x53fc7efdedec445dL, FunctionApplication);
    builder.put(0x45da4fd5064877c7L, FunctionDefinition);
    builder.put(0x534698153447f872L, FunctionTypeNode);
    builder.put(0x1d87d6d81a2ba502L, GenericApplication);
    builder.put(0x7fa876a53c3d926L, Guard);
    builder.put(0x1546fb5201c3f12L, IIConstructor);
    builder.put(0x3d75775c30a6c3a8L, IIFunction);
    builder.put(0x3d75775c31780df9L, IIOperator);
    builder.put(0x1abe72387e906599L, IITCLAll);
    builder.put(0x1abe72387e90659aL, IITCLConstructor);
    builder.put(0x1abe72387e90659cL, IITCLItem);
    builder.put(0x1abe72387e90659dL, IITConstructorList);
    builder.put(0x1abe72387e906535L, IIType);
    builder.put(0x7fa876a53c3d994L, IfThenElse);
    builder.put(0x5d5f9b6a6ea5cdf1L, ImplicitDefinition);
    builder.put(0x7fa876a53c3d877L, Import);
    builder.put(0x3d75775c30a60967L, ImportAs);
    builder.put(0x3d75775c30a60968L, ImportHiding);
    builder.put(0x3f5c5828a3892c26L, ImportItem);
    builder.put(0x3f5c5828a389112dL, ImportItems);
    builder.put(0x7f24f41c3f28279eL, ImportReference);
    builder.put(0x7f24f41c3f273a81L, ImportedEntityApplication);
    builder.put(0x1546fb52035f167L, ImportedTypeReferenceUsage);
    builder.put(0xc54adc878e2b32cL, IncompleteCommand);
    builder.put(0x5feee6d035b32de1L, Infix);
    builder.put(0x5feee6d035b32dcdL, InfixAbstract);
    builder.put(0x5feee6d035b32de0L, Infixl);
    builder.put(0x5feee6d035b32dccL, Infixr);
    builder.put(0x53469815341d2be5L, IntTypeNode);
    builder.put(0x7fa876a53c3d90aL, IntegerValue);
    builder.put(0x5aa4f79b7b0fde27L, LCQArrowAssignment);
    builder.put(0x5aa4f79b7b0fde51L, LCQGuard);
    builder.put(0x5aa4f79b7b0fdddfL, LCQLet);
    builder.put(0x5aa4f79b7b0fddd5L, LCQualifier);
    builder.put(0x3575c62ea7ed3709L, LPExpression);
    builder.put(0x3575c62ea7ed3719L, LPLambda);
    builder.put(0x7fa876a53c3d907L, Lambda);
    builder.put(0x3575c62ea7ed3708L, LambdaPart);
    builder.put(0x5d5f9b6a6f2e03edL, LateLoader);
    builder.put(0x7fa876a53c3d995L, Let);
    builder.put(0x66fa4fc65829ede0L, LetDefinitions);
    builder.put(0x76d2ad9a0d655de7L, LineComment);
    builder.put(0x7fa876a53c3d902L, List);
    builder.put(0x5aa4f79b7b0fdd64L, ListComprehension);
    builder.put(0x5aa4f79b7b0fdd02L, ListEnumeration);
    builder.put(0x5aa4f79b7b0fdd34L, ListRange);
    builder.put(0x534698153429d2f0L, ListTypeNode);
    builder.put(0x1987c8739f322057L, Literal);
    builder.put(0x76d2ad9a0d65ea05L, LocalTypeReferenceUsage);
    builder.put(0x3d75775c3006a1dbL, MEFunction);
    builder.put(0x3d75775c30145069L, MEOperator);
    builder.put(0x3d75775c30218792L, MEPMImport);
    builder.put(0x3d75775c3021876eL, MEPMReference);
    builder.put(0x3d75775c3021876dL, MEPMSelf);
    builder.put(0x3f5c5828a38868c6L, MEPModule);
    builder.put(0x1abe72387e5e0c00L, METCLAll);
    builder.put(0x1abe72387e5e0c1fL, METCLConstructor);
    builder.put(0x1abe72387e5e18c0L, METCLItem);
    builder.put(0x1abe72387e5e0bc3L, METConstructorList);
    builder.put(0x1abe72387e518cb6L, METype);
    builder.put(0x7fa876a53c3d830L, Module);
    builder.put(0x3f5c5828a38868c5L, ModuleExport);
    builder.put(0x3d75775c2fa0f90fL, ModuleName);
    builder.put(0x3d75775c2fa108aaL, ModuleNameFinal);
    builder.put(0x3d75775c2fa108cbL, ModuleNamePreFinal);
    builder.put(0x46dba762a6838a3bL, NegativeExpression);
    builder.put(0x7a213c18049985e1L, NodeCONID);
    builder.put(0x1cff861b633abcd8L, NodeOperator);
    builder.put(0x7a213c18049985e2L, NodeVARID);
    builder.put(0x53fc7efdedec89a3L, OperatorApplication);
    builder.put(0x4b2fbc03f0258a57L, OperatorReference);
    builder.put(0xebc8ab068694d54L, Otherwise);
    builder.put(0x75a03de5fd2a22cdL, PBracket);
    builder.put(0x3f5c5828a38951f8L, PConstructor);
    builder.put(0x73138b1e057e2d74L, PLEBPatternArgument);
    builder.put(0x73138b1e057e2d73L, PLEBPlaceholder);
    builder.put(0x3f5c5828a38951f7L, PList);
    builder.put(0x3f5c5828a38952abL, PListBracket);
    builder.put(0x3f5c5828a3895253L, PListColon);
    builder.put(0x3f5c5828a389529bL, PListVar);
    builder.put(0x3f5c5828a38951f9L, PLiteral);
    builder.put(0x3f5c5828a38951f6L, PTuple);
    builder.put(0x3f5c5828a3895209L, PVarName);
    builder.put(0x2172e4e5ac3793bbL, PVarOperator);
    builder.put(0x3f5c5828a38951fbL, PVarWildcard);
    builder.put(0x3f5c5828a38951faL, PVariable);
    builder.put(0x3f5c5828a3895192L, Pattern);
    builder.put(0x3f5c5828a3895193L, PatternArgument);
    builder.put(0x3f5c5828a3895194L, PatternFunction);
    builder.put(0x155bf5aa2841626bL, PatternFunctionInGroup);
    builder.put(0x3f5c5828a38951c8L, PatternOperator);
    builder.put(0x4dbb8871591a2c8aL, PatternOperatorInGroup);
    builder.put(0x1db1c5d8465bf8faL, PatternWrapper);
    builder.put(0x4b2fbc03f0235974L, PrimaryExpression);
    builder.put(0x7a213c18049985a6L, QCONID);
    builder.put(0x7a213c18049a298fL, QVARID);
    builder.put(0x76d2ad9a0d65e9f1L, Simpletype);
    builder.put(0x7fa876a53c3d82fL, Skeleton);
    builder.put(0x78ac394b5a4212f4L, StringTypeNode);
    builder.put(0x7fa876a53c3d909L, StringValue);
    builder.put(0x7fa876a53c3d8edL, Term);
    builder.put(0x5feee6d035b3ddeeL, TopExpression);
    builder.put(0x1987c8739f20387eL, TrueValue);
    builder.put(0x7fa876a53c3d903L, Tuple);
    builder.put(0x53469815345ff050L, TupleTypeNode);
    builder.put(0x2854fa195e0a238bL, Type);
    builder.put(0x253325724ebcd01cL, TypeA);
    builder.put(0x253325724ee53d72L, TypeB);
    builder.put(0x7fc1a9722da278d2L, TypeCarrier);
    builder.put(0x76d2ad9a0d65ea2dL, TypeFunction);
    builder.put(0x76d2ad9a0d662e92L, TypeList);
    builder.put(0x253325724e94e0bcL, TypeName);
    builder.put(0x253325724e94e04bL, TypeReference);
    builder.put(0x1546fb5207ceb0bL, TypeReferenceUsage);
    builder.put(0x76d2ad9a0d662e79L, TypeTuple);
    builder.put(0x76d2ad9a0d65e9f4L, TypeVariable);
    builder.put(0x253325724ebcd023L, TypeVariableReference);
    builder.put(0x682a3f2d0572c9a7L, TypeWrapper);
    builder.put(0x4f4212f5c8d48453L, UnknownTypeNode);
    builder.put(0x4b2fbc03f0258a31L, VariableReference);
    builder.put(0x7fa876a53c3d993L, WherePart);
    myIndex = builder.seal();
  }

  /*package*/ int index(SConceptId cid) {
    return myIndex.index(cid);
  }

  public int index(SAbstractConcept concept) {
    return myIndex.index(concept);
  }
}
