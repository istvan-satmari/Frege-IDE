Enter po kliknuti hadze na novy riadok, namiesto vytvorenia dalsieho konceptu
-------------------------------------------------------
data Maybe a = Just|
- ked kliknem enter, da ma na novy riadok namiesto vytvorenia dalsieho konceptu v zozname, musim ist na zaciatok pred "Just"
- co s tym?
	- na druhej strane funguje, ked kliknem "|", cize to vyzera nakoniec rozumne... huh





--------------------------------------------------------------------------------------------------------------------------


Jak debuggovat?
-------------------------------------------------------
- vyuzit syntakticky konstrukt:
message info "Sprava", <no project>, <no throwable>;
- tato sprava sa potom zobrazi v dolnom okne v karte "messages"



Ako spravit, aby sa konstanty dali editovat?
--------------------------------------------------------
- napr. "data Maybe", chceme umoznit, aby sa slovo "data" dalo editovat
- v editore > styles > "editable: true"
- tymto je mozne nastavit empty line, aby sa na nej dalo priamo pisat
- prip. este takto:
/empty cell: <constant>
	editor > styles > "editable: true"
- typicky je vsak tento prepis sposobeny tym, ze mame abstraktny koncept, ktoreho editor je tvaru: #alias#
- jeho potomkovia potom maju nadefinovany iba alias, ale ziaden editor
- bunka "alias" je ale vzdy editable a nejde zmenit



Ako nastavit default defaultny koncept pri editacii children nejakeho konceptu?
--------------------------------------------------------
- v ramci editoru > element factory:
(scope, node) -> node<> {
	return new node<EmptyLine>();
}



Viacero druhov editoru pre ten isty koncept
--------------------------------------------------------
- zvolme bunku "alternation" v editore
- inspector: alt. condition:
(scope, editorContext, node) -> boolean {
	return node.myChildren.isNotEmpty;
}
- tymto mozeme pre "true" zobrazit jednu vec a pre "false" druhu



Kedy sa ma pridat novy riadok v indent-layout?
--------------------------------------------------------
- editor: style: "indent-layout-new-line: true"
- pokial aj chceme posunut to, co bude na novom riadku, treba toto:
- editor: style: "indent-layout-indent: true"
- da sa urcit aj podrobne:
- editor > indent layout collection
- inspector > style > indent-layout-new-line: query
	(editorContext, node) -> {
		// kedy ma pridat line break a kedy nie, da sa takto programovo nastavit
	}
	
	
	

Drobnosti k indent layout
--------------------------------------------------------
- pripomienka:
	[> <] - horizontal collection
	[\ \] - vertical collection
	[- -] - indent collection
	(> <) - horizontal child list
	...

- ked mame:
[> "medzera" (\ children \) <]
... tak pred kazdym child bude dana medzera (lebo ta zostane na vrchnom riadku)

- ked mame:
[- "medzera" (- children -) -]
... s tym, ze kazdy child sa urci, ze ma byt na osobitnom riadku (cez alt + enter), tak medzera bude iba pred prvym prvkom

Cez indent layout sa da teda dosiahnut korektne uzatvorkovanie, napr.:
( if condition )
  then b1
  else b2
  - takto by sa spraval pre prvy pripad
		  
( if condition
  then b1
  else b2 )  
  - takto by sa spraval pre druhy pripad (indent layout)
  

  
show-if + automaticke akcie po pripisani textu
--------------------------------------------------------
- show-if v editore mozno pouzit na zneviditelnenie sipeciek "<< ... >>", pokial tam maju byt children
- povedzme, ze v editore mame: "constant | children-cells"
- chceme, aby po napisani textu tesne napravo od "constant" sa automaticky children zviditelnili
- zvolime "constant", editor: style: "side-transform-anchor-tag: ext_1" (lubovolny tag, cez ktory sa budeme odkazovat)
- vytvorime transformation menu action
	- musi byt "right transform node" v tomto pripade
	- musime urcit "tag", aby bol zhodny s pouzitym v "style"
	- tu naopak v "condition" urcime opacnu podmienku, nez v show-if
		- (chceme, aby sa zobrazil iba vtedy, ked children je prazdny, inak uz zobrazeny asi je)
	- add custom items:
		- matching text: po napisani akeho textu sa ma transformacia previest
		- je mozne pouzit aj "parameterized item" pre viacere matching texty:
			query
				(operationContext, scope, model, sourceNode)->list<string> {
					return new arraylist<string>{"heading", "not"};
				}
			- potom sa nan mozno odkazovat:
				do transform
					...
					if (parameterObject.equals("heading") { ... }
					...
- toto funguje len na konstanty a vseobecne cokolvek, co je "celistve"
	- napr. pokial sa text "myVal" pochopi ako referencny node, tak je zrazu "celistvy" a transformacne akcie uz nan budu fungovat
	- ale pokial ide o volny text "my custom value", tak transformacne akcie si s tym neporadia
	- v tom druhom pripade tym padom je mozno zle narvhnuta gramatika na konceptualnej urovni



Defaultny prikaz ma byt "EmptyLine"
--------------------------------------------------------
- vytvorit dany koncept "EmptyLine"
- jeho editor: "constant", style: "editable: true"
- dedi: "IDontSubstituteByDefault" (aby ho neponukalo v ctrl + space menu)

- typicky staci nastavit len takuto substituciu:
default substitute menu for concept EmptyLine
  << ... >>

- nicmenej, niekedy sposobi, ze takyto uzol uz vobec nie je substituovatelny za ziadne iny
- v takom pripade by malo zvycajne pomoct:
default substitute menu for concept EmptyLine
  subconcepts menu <no filter>

- specialna akcia pre situaciu (btw, toto nemam overene):
	- pokial bude zmeneny na akukolvek instanciu "LineStyle" (t.j. pokial "DottedLineStyle" dedi od "LineStyle", tak aj vtedy sa tato akcia zavola)
	- zmena moze prebehnut akokolvek, napr. napisanim aliasu daneho "LineStyle", ci klasickym "ctrl + space"
	- tu totiz "LineStyle" realne nededil od "EmptyLine" ani jeho predka, je to uplne iny koncept a preto treba "wrap"
default transformation menu for concept EmptyLine
  section(completion) {
    include <default substitute menu> for link: <default>
    ----------
    wrap substitute menu
      target node <default>
      menu to wrap default substitute menu for LineStyle
      handler
        (editorContext, node, model, pattern, createdNode, targetNode)->void {
          node<IncompleteCommand> cmd = new initialized node<IncompleteCommand>();
          node.replace with(cmd);
          cmd.lineStyle.set(createdNode);
          editorContext.selectWRTFocusPolicy(cmd);
        }
  }



Preco mi zobrazuje polozku v CTRL + SPACE menu, pokial som ho nastavil na "IDontSubstituteByDefault"?
--------------------------------------------------------
- staci pridat pre dany koncept default substitute menu (a ano, je to nutne):

default substitute menu for concept PTuple
  << ... >>



Placeholder pre nekompletny concept
--------------------------------------------------------
- pokial nejaky koncept nie je uplne dokonceny, a nemozno ho uznat, ale zuzil vyber alebo sluzi ako nejaky placeholder
- novy koncept: "IncompleteCommand"
- implementuje "IDontSubstituteByDefault" (nech ho neponuka v "ctrl + space")
- je pren vytvoreny default substitute menu (predpokladam, ze kvoli tomu, aby sa lahko dal pretypovat na "siblings" - z hladiska dedicnosti):
default substitute menu for concept IncompleteCommand
  << ... >>
- editor vyzera nejak takto:
[- % lineStyle % ^F <constant> -]
	- lineStyle je "proste uz nieco vybrate", ale samo o sebe nekompletne
	- ^F spolu s <constant>:
		<no base style> {
		  editable : true
		  text-foreground-null-color : red
		}

		// Tu specifikujeme, cim moze byt nahraditelne:
		menu parts:
		replace node (custom node concept)
		   replace with : DrawLine
		replace node (custom node concept)
		   replace with : DrawRect

		// Tu specifikujeme, co sa ma zobrazit, pokial je prazdne (ziaden napisany text):
		Constant cell:
		text*: <draw command>



Jak nainicializovat children pri vytvoreni nejakej instancie, node-u?
--------------------------------------------------------
- concept > behaviour > constructor:
constructor {
  this.definitions.add new initialized(EmptyLine);
}



Jak pridavat dalsie deti, pokial mame karet na konci nejakeho childu v ramci nejakeho konceptu?
--------------------------------------------------------
- napr. predpokladajme:
data Maybe a = Just a | Nothing*
- predpokladajme, ze * je karet
- jak pridat dalsi child?
- bud zadanim enter alebo takeho isteho character-u, ako je uvedeny separator tychto children
- v tomto pripade ide o |
- pokial nechyta, to znamena, ze je separator zle zadany a treba vymenit za iny



Jak force-nut pridavanie deti stlacenim klavesy enter, prip. jak tomu zabranit?
--------------------------------------------------------
- napr. BinaryExpressions, ktory sa sklada z additionalParts : BinExPart[0..n]
- v editore teda pre BinaryExpressions mame kolekciu deti (additionalParts), tu rozklikneme v inspector-e
- priradime novy "action map":

applicable concept: BinaryExpressions

action INSERT description : <no description>                                                                                                                                                                      
              can execute : true                                                                                                                                                                                  
              execute : (editorContext, node)->void { 
				// Tu implementujeme bud pridanie noveho potomka (co je default chovanie)
				// pripadne naopak inu akciu, pokial nechceme enterom pridavat nove deti
			  }

			  
			  
Zrazu nejde odstranit nejaky prvok v zozname deti			  
-------------------------------------------------------
- napr. majme koncept A, ktory obsahuje [0..n] deti typu B
- editor je jendoduchy, ide len o zoznam deti konceptu A
- ziadna polozka ale nejde odstranit, jak to?
- s najvacsou pravdepodobnostou bude v niektorom z deti B (prip. priamo na B) namapovana akcia "action map DELETE", ktory nema korektne 
udanu podmienku na neprazdnost
- napr.:

action DELETE description : Removes the first TopExpression and its associated operator.                                                                                                                                                                                                                   
              can execute : (editorContext, node)->boolean { 
							  // Bez tejto podmienky by to nefungovalo dobre
							  // (podmienka hovori, ze node musi byt neprazdny, aby sa uplatnila tato akcia namiesto defaultnej)
							  return node.additionalParts.isNotEmpty; 
							}                                                                                                       
              execute : (editorContext, node)->void { 
						  ...
						}



Konvertory medzi jednotlivymi konceptami
--------------------------------------------------------
node factories Converters

node concept: SimplifiedFormDescription
   description : <none>
   set-up : (newNode, sampleNode, enclosingNode, model)->void {
  ifInstanceOf (sampleNode is StringDescription original) {
    newNode.detail = original.value;
  }
  ifInstanceOf (sampleNode is FormDescription original) {
    newNode.detail = original.detail;
    newNode.firstTimeApplicant = original.firstTimeApplicant;
    newNode.requestor = original.requestor;
  }
}

node concept: FormDescription
   description : <none>
   set-up : (newNode, sampleNode, enclosingNode, model)->void {
  ifInstanceOf (sampleNode is StringDescription original) {
    newNode.detail = original.value;
  }
  ifInstanceOf (sampleNode is SimplifiedFormDescription original) {
    newNode.detail = original.detail;
    newNode.firstTimeApplicant = original.firstTimeApplicant;
    newNode.requestor = original.requestor;
  }
}

node concept: StringDescription
   description : <none>
   set-up : (newNode, sampleNode, enclosingNode, model)->void {
  ifInstanceOf (sampleNode is SimplifiedFormDescription original) {
    newNode.value = original.detail;
  }
  ifInstanceOf (sampleNode is FormDescription original) {
    newNode.value = original.detail;
  }
}



Akcia transformacie (substitucie) na zaklade realne napisaneho textu
--------------------------------------------------------
- napr. majme abstraktny koncept, ktory sa moze transformovat na nejaky zo svojich konkretnych
- na abstraktnom nadefinujeme akciu subtitucie ("Abstract_SubtituteMenu"):

default substitute menu for concept Abstract
  // zabezpeci, aby sa stale ukazovali zdedene polozky pri "ctrl + space"; nasledne ich mozno este vyfiltrovat
  subconcepts menu <no filter>
  ----------
  substitute action(output concept: default)
	// co sa ma stat
    create node (parentNode, currentTargetNode, link, editorContext, model, pattern)->node<Abstract> {
      node<Concrete1> node = new initialized node<Concrete1>();
      node.value = pattern;

      return node;
    }
	// kedy sa ma stat
    can substitute (parentNode, currentTargetNode, link, editorContext, model, pattern, strictly)->boolean {
      return pattern.isNotEmpty;
    }
    matching text (parentNode, currentTargetNode, link, editorContext, model, pattern)->string {
      return pattern;
    }

- zaujimava podmienka moze byt napr. tato:
	sequence<concept<AbstractRequestDescription>> concreteSubConcepts = concept/AbstractRequestDescription/.sub-concepts(parentNode.model).where({~it => !it.isAbstract(); });
	return pattern.isNotEmpty && concreteSubConcepts.all({~concept => !concept.conceptAlias.startsWith(pattern); });

- pozor, toto plati jak pre samotny abstraktny koncept, tak aj pre jednotlive subkoncepty aj po tom, co uz boli vytvorene
	- ak chceme predist tomuto chovaniu, treba nieco v style:
	currentTargetNode.concept.isExactly(Definition)



Zrazu nevytvara instancie hned, ked napisem napr. "data" (Prazdny riadok by default)
--------------------------------------------------------
- pozor, je to skutocne sposobene tym, ze som dal "default editor transform"
- pre defaultne children radsej pouzit navod ako popisany vyssie



Na ake bunky mozno zavesit transformaciu?
-------------------------------------------------------
- predpokladajme koncept A obsahujuci ako child koncept B
- predpokladajme, ze editor pre koncept A vyzera nejak takto:
	[B-editor] constant-cell
- kde [B-editor] je editor konceptu B

- tak transformaciu asociovanu s konceptom A mozno vlozit len pre jeho constant-cell
	- vytvorime tranformaciu
	- potom v inspectore pre constant-cell nastavime:
	transformation menu: named menu PomenovanaTransformaciaAsociovanaSKonceptomA

- pokial potrebujeme tranformaciu na bunke [B-editor], tak potom ju musime asociovat s konceptom B
- bud pojde o default trasformation pre koncept B
- alebo pojde o named transformation, ktoru zasociujeme s nejakou konstantnou bunkou editoru konceptu B

- transformacie sa daju aj includovat:
	transformation menu ... for concept ...
	  section({ side transform : right }) {
		group
		  variables
			<< ... >>
		  condition <no condition>
		  include default menu for targetNode(editorContext, node, model)->node<> {
			node.parent; 
		  }
	  }
- mozeme includovat pomenovanu alebo default transformaciu
- naco je to dobre?
- prehladnost (rozdelenie default tranformacie na niekolko pomenovanych)
- prip. toto:
- predpokladajme situaciu: mame koncepty A a B
- editor konceptu A je [B-editor], t.j. len vklada editor pre koncept B
- potrebujeme trasnformaciu konceptu A, t.j. vytvorime tranformaciu asociovanu s konceptom B
- zial mame aj koncept C, ktory tiez obsahuje B, na ktory sa nema previest dana tranformacia
- bud teda mozeme previest can execute pre kontrolu
- prip. mozeme nadefinovat transformaciu asociovanu s konceptom A ktora pre A samozrejme nebude robit nic, 
	ale includuje ju este B pre seba z rodica - cize pokial je jeho rodic prave C, tak sa nenaincluduje nic, ale pokial A, tak
	bude fungovat, co chceme

- BTW, je nutne znovu upozornit, ze transformacia musi byt vzdy	zavesena na koncepte, z ktoreho bunky sa deje
- predpokladajme napr. koncept A, ktory obsahuje koncept B ako child
- predpokladajme, ze editor pre koncept A vyzera nejak takto:
	[B-editor] constant-cell
- predpokladajme, ze B obsahuje jedinu stringovu property, co je jedina editovatelna polozka
- potom nejde vytvorit transformaciu nijak inak, nez ju zavesit na koncept B
- pre prehladnost sa casto tranformacia vesia na koncept A a potom iba includuje pre B
	
- upozornime este na tuto situaciu:
- mame abstraktny koncept A, od ktoreho dedi abstraktny koncept B, od ktoreho dedi C
- na A mame zavesenu default tranformation menu
- na C sa nebude aplikovat - musi definovat default transformaciu aj B!



Jaky je pattern pri rieseni, na ake koncepty zavesit transformacie?
-------------------------------------------------------
- suvisi s predchadzajucim bodom
- vezmime na priklade Frege-IDE jazyka
- predpokladajme situaciu #1:
	- mame vseobecny (ale konkretny) koncept Expression
	- Expression sa sklada z [0..1] TopExpression a [0..1] StaticType
	- TopExpression je abstraktny koncept
	- z TopExpression dedi PrimaryExpression, co je tiez abstraktny koncept
	- z PrimaryExpression dedi koncept StringLiteral 
	- StringLiteral nema potomkov ani child koncepty, t.j. transformacie nadefinovane v PrimaryExpression sa aplikuju aj tu
	- existuje zaroven koncept Tuple, ktory sa sklada z [1..n] Expression, napravo od ktoreho ked nieco specificke napiseme, tak sa ma previes nejaka konkretna tranformacia
- jak riesit situaciu #1?
	- zaujima nas vlastne ten Tuple
	- kedze vyvolavacom transformacie su jednotlive Expressions, z ktorych sa Tuple sklada, musime nadefinovat default side transformaciu pre Expression
	- moze sa to zdat ako zbytocne, kedze Expression tym, ze sa sklada z TopExpression a StaticType, by mala byt nadefinovana dana trasnformacia iba v jeho child konceptoch, ale treba uvazit situaciu, kedy nejaky iny koncept bude od Expression dedit a nadefinuje napravo v editore konstantnu bunku - tato "redundancia" nas automaticky zachrani bez nutnych dalsich zasahov
	- cize pattern je nadefinovat transformaciu pre ten koncept, ktoreho sa to "konceptualne" tyka, a nie ktoreho sa to tyka z hladiska editoru
	- v tejto chvili sa ale transformacia nebude prevadzat - pretoze Expression nema konstantne bunky editoru a len sa sklada z [0..1] TopExpression a [0..1] StaticType
	- kedze oba mozu stat ako bunka editoru najviac vpravo, je nutne includovat defaultnu trasnformaciu z Expression v oboch 
	- pri includovani je nutne urcit, ze sa transformacia tyka ich rodica a v ramci condition udame, ze sa ma previest len vtedy, pokial ich rodic je typu Expression
	- bez ohladu na to, ake dalsie transformacie pribudnu do Expression, tento include automaticky zabezpeci prisposobenie v pripade buducich dalsich rozsireni a zmien
	- kedze z TopExpression dedi PrimaryExpression, ktory je abstraktny (resp. skor ide o to, ze z neho dedia dalsie koncepty), je nutne aj tu includovat... ale defaultne transformacie z TopExpression
	- totizto nas nezaujima, aky je prapredok rodica PrimaryExpression, nas len zaujima, aby sa propagovalo vsetko, co plati pre TopExpression, aj pre deti PrimaryExpression, pretoze tu plati IS-A vztah (je divne, ze neplati v MPS automaticky)
	- StringLiteral uz nemusi nic includovat, pokial nepredpokladame, ze by niekto dedil z tohto konceptu
- predpokladajme situaciu #2:
	- navazujeme na situaciu #1
	- predpokladajme, ze mame dalsi koncept SeveralTopExpressions, ktory sa sklada z [1..n] TopExpression, a ma sa na nom previest transformacia pri napisani specifickeho textu napravo od toho posledneho TopExpression, z ktoreho sa sklada
	- ako som uviedol v ramci #1, tranformaciu definujeme pre koncept, ktoreho sa to tyka "konceptualne" a nie "editorovo", v tomto pripade ide o TopExpression
	- v ramci condition musime v tejto transformacii urcit, ze rodic TopExpression je typu SeveralTopExpressions a ze zaroven sucasny TopExpression je ten najviac vpravo, t.j. posledny z children SeveralTopExpressions, ale toto je asi zrejme
	- pokial sme postupovali podla #1, nic viac nemusime riesit, pretoze predbezne includovania sa postaraju o zvysok


	
Transformacia medzi zatvorkami zavesena o konstantne bunky
--------------------------------------------------------
- mam na mysli nieco take: ()
- jednotlive zatvorky su konstantne bunky editoru
- chceme, aby pokial je karet vnutri zatvoriek, aby sa aplikovala nejaka nadefinovana transformacia
- normalne by to bolo trivialne, t.j. na lavu zatvorku zavesime transformaciu po pravej strane
- pokial ale na zatvorky hodime punctuation-right a punctuation-left n a true, aby boli blizko seba, tak to nebude fungovat
- dovody mi nie su jasne, nicmene riesenie je, ze na lavu zatvorku zavesim transformaciu a na pravu (jedine na nu) aplikujeme styl
	punctuation-left: true
- takto budu pri sebe a bude aj fungovat transformacia

- pattern by bol zavesit na lavu zatvorku cell action map pre INSERT, kde prida novy abstraktny element do daneho zoznamu
- pokial takato zatvorka je potom odsunuta od zvysku obsahu, je mozne na nu aplikovat podmieneny styl:
apply-if : LeftBracketPunctuation condition: (editorContext, node)->boolean { 
  node.items.isNotEmpty; 
}

	
		
	
Jak uplatnit rovnaku tranformaciu pre vsetkych potomkov nejakeho abstraktneho konceptu?
-------------------------------------------------------
- majme abstraktny koncept, od ktoreho dedi niekolko konkretnych konceptov
- chceme, aby sa spolocna transformacia aplikovala pre kazdy z tychto konkretnych konceptov
=> je nutne vytvorit default transformation menu pre dany abstraktny koncept

default transformation menu for concept Line
  section({ side transform : right }) {
    action
      text (editorContext, node, model, pattern)->string {
        "2";
      }
      can execute <always>
      execute (editorContext, node, model, pattern)->void {
        node.replace with new initialized(ConcreteLine2);
      }
      <no additional features>
  }

		

Jak pridat novu bunku po transformacii tak, aby sa automaticky substituovala za pozadovany koncept?
-------------------------------------------------------
- predpokladajme scenar, ze mame bunku v editore: mytext
- napravo od nej je mozne pridat dalsi argument, co je koncept abstraktneho typu
- nicmenej konkretne typy zahrnaju:
	- alias "["
	- alias "("
	- alias "{"
- jak zabezpecit, aby sa okamzite previedla substitucia za pozadovany konkretny koncept?
=> nastavime text danej transformacie prazdny

action
  text (editorContext, node, model, pattern)->string {
    "";
  }
  can execute <always>
  execute (editorContext, node, model, pattern)->void {
    // predpokladajme, ze parent obsahuje kolekciu deti daneho abstraktneho typu
	// novy node MUSI byt select-nuty, pretoze novo napisany text z patternu sa musi odovzdat abstraktnemu node-u, 
	// z ktoreho sa prevedu defaultne substitucie podla aliasov
	node.parent : MyParentConcept.collection.add(new initialized node(MyAbstractType)).select[in: editorContext, cell: MOST_RELEVANT]; 
  }
  <no additional features>



Jak transformovat napravo od konceptu, ktoreho bunka v editore je string?
-------------------------------------------------------
- da sa jedine pokial dana string property nesmie obsahovat sama o sebe medzery
- v takom pripade staci zajst na constraints a nastavit:

can be child <none>

can be parent <none>

can be ancestor <none>

property {value}
get <default>
set <default>
is valid (propertyValue, node)->boolean {
  !propertyValue.contains(" ");
}



Preco niekedy nefunguju akcie transformacie, aj ked su korektne nastavene?
-------------------------------------------------------
- viacero moznosti
- scenar 1:
	- mame abstraktny koncept A, ktory ma definovanu defaultnu transformaciu
	- mame koncept AA, ktory dedi od A, ktory ma tiez definovanu transformaciu (nie nutne defaultnu)
	- na koncept AA sa transformacia pre A tym padom nebude sama o sebe aplikovat
	=> jak to vyriesit?
		- napr. pridat do lokalnej transformacie pre AA include z nadradenej:
		section({ side transform : right }) {
		  include default menu for A for current node
		}

- scenar 2:
	- mame abstraktny koncept A, ktory ma definovanu defaultnu transformaciu
	- mame koncept AA, ktory dedi od A, a obsahuje B
	- B je abstraktny koncept, od ktoreho dedi viacero konceptov (napr. B1, B2, ..., BN)
	- je nadefinovany default substitution wrapper, ktory obaluje konkretny koncept typu B do AA
	- na AA sa vsak neuplatni defaultna transformacia od A
	=> jak to vyriesit?
		- je nutne nad konceptom B (nie nad AA!) nadefinovat defaultnu transformaciu
		default transformation menu for concept B
		  section({ side transform : right }) {
			include default menu for A for targetNode(editorContext, node, model)->node<A> {
			  node.parent : AA;
			}
		  }

- scenar 3:
	- mame abstraktny koncept A, ktory ma definovanu defaultnu transformaciu
	- mame koncept AA, ktory dedi od A, a obsahuje B
	- B je vsak node, ktory obsahuje string property
	- na AA sa vsak neuplatni defaultna transformacia od A
	=> jak to vyriesit?
		- tu sice nie je wrapper, ale i tak je nutne nadefinovat defaultnu transformaciu pre koncept B
		default transformation menu for concept B
		  section({ side transform : right }) {
			include default menu for A for targetNode(editorContext, node, model)->node<A> {
			  node.parent : AA;
			}
		  }
		- to vsak nestaci a je nutne este do konceptu B pridat constraint:
		property {value}
		  get <default>
		  set <default>
		  is valid (propertyValue, node)->boolean {
			// Must not contain spaces
			return !propertyValue.contains(" ");
		  }

- scenar 4:
	- mame abstraktny koncept A, ktory ma definovanu defaultnu transformaciu po napisani napr. "!"
	- transformacia sa vsak neprevedie okamzite, ale je ju nutne odkliknut cez enter
	=> jak to vyriesit?
		- typicky je to sposobene tym, ze okrem takychto transformacii:
		text (editorContext, node, model, pattern)->string {
		  "!";
		}
		- mame nejake ambiguitne, t.j. tie, co tiez zacinaju na "!", prip. rovno vracaju cely "pattern"

- scenar 5:
	- mame abstraktny koncept A, ktory ma definovanu defaultnu transformaciu
	- mame koncept AA, ktory dedi od A, a obsahuje B
	- B je node, ktory obsahuje string property
	- na AA sa uplatni defaultna transformacia od A, to mame osetrene
	- mame vsak este koncept C, ktory obsahuje AA
	- C ma svoje defaultne transformacie, nicmenej sa neuplatnia
	=> tu je opat nutne pre koncept B naimplementovat, aby includoval transformacie od C
	default transformation menu for concept B
	  section({ side transform : right }) {
		include default menu for C for targetNode(editorContext, node, model)->node<C> {
		  (node.parent : AA).parent : C;
		}
	  }
	- pozor na to, ze sa niekedy moze kryt s inymi includovanymi transformaciami!
		- v takom pripade je nutne vytvorit group s condition, ktora limituje, napr.:
		group 
		  variables 
			<< ... >> 
		  condition (editorContext, node, model)->boolean { 
			// ...
		  } 
		  include default menu for C for targetNode(editorContext, node, model)->node<C> {
			(node.parent : AA).parent : C;
		  }



Jak po akcii vybrat nejaky uzol?
-------------------------------------------------------
node.select[in: editorContext, cell: <no cell selector>, selectionStart: <selectionStart>];
	- cell: ktora bunka v ramci editoru sa ma vybrat, oznacovana cez "cell id" v inspector-e
		- vacsinou "MOST_RELEVANT" poskytuje dobru heuristiku
	- selectionStart: pozicia este v ramci tej bunky (ako string char position)



Jak rekurzivne naparsovat uzivatelom zadany text?
-------------------------------------------------------
- mam koncept FunctionDefinition, ktory dedi od Definition
- rozhodnutie, ze sa ma vybrat ten, vie ucinit az ked uzivatel napise "="
- dovtedy vsak mohol vypisat kopec argumentov funkcii, ktore by sli naparsovat ale velmi tazko!
f (x : xs) 7 [1, 2, 3] =
- co s tym? jak naparsovat jednotlive argumenty, ktore uzivatel uviedol, do konceptov?

- oficialne to nejde, da sa len pouzit isty pattern:
	- mat koncepty, ktore predstavuju "incomplete command"
	- tie postupne transformovat
	- ina moznost je pouzit intentions (alt + enter)



Jak ziskat koncept primitivneho datoveho typu? (Don't repeat yourself)
-------------------------------------------------------
- viem napr. cez "concept/NodeCONID/" sa odkazat na koncpet "NodeCONID"
- co ak sa chcem odkazat na primitivny datovy typ "CONID"?
	- kvoli DRY, nechcem mat rozkopirovane regexp-y po celej aplikacii
- sice toto riesenie nie je uplne to iste, funguje:
	- v casti "behavior" nadefinujme zopar statisckych funkcii, ktore vracaju potrebne regexp-y
	- mozno sa na ne odkazat cez concept/NodeCONID/.menoStatickejFunkcie()
	- takto je to maximalne v dvoch kopiach, co nie je zas tak zle



Umoznit pisat hned za konstantnym slovom v editore
--------------------------------------------------------
- neposlusny editor - stale vytvara padding v niektorych pripadoch
- napr. module name (_nazov, nazov, nazov_)
- riesenie je jednoduche:
	- oznac konstantny cell v editore
	- uprav style tak, aby obsahoval:
		a) punctuation-right: true		-- nevytvori ziaden padding oproti bunke napravo
		alebo
		b) padding-right: -1			-- 0 je prave 1 medzera, cize -1 je bez padding-u



Akcie po stlaceni konkretnej klavesy, resp. co sa ma stat, ked uzivatel stlaci "delete" alebo "backspace"
--------------------------------------------------------
- oznacit bunku v editore a nastavit jej "keymap" alebo "action map"
- dany "keymap" ci "action map" musel byt nadefinovany
- (t.j. pravy klik do editoru, create new keymap, action map, ...)

- keymap
- mozno na bunku v editore hodit nejaku akciu na klavesy; podrobnejsie:
- a function which is executed when a key map item is triggered (returns nothing)
- a set of keystrokes which trigger this key map item
- a boolean function which determines if a key map item is applicable here (if not specified, then it's always applicable). If a key map item is not applicable the moment it is triggered, then it will not perform an action.
- you may specify caret policy for a key map item. Caret policy says where in a cell a caret should be located to make this key map item enabled. Caret policy may be either first position, last position, intermediate position, or any position. By default, caret policy is "any position." If a caret in a cell does not match the caret policy of a key map item the moment it is triggered, then this key map item will not perform an action.

action map
- co sa ma diat po specifickych akciach na bunky
- castejsie pouzivane
- napr. DELETE alebo BACKSPACE na konkretnu bunku
 action DELETE description : <no description>
    execute : (node, editorContext)->void {
        node < ExpressionStatement > expressionStatement = node . replace with new ( ExpressionStatement ) ;
        expressionStatement . expression . set ( node . expression ) ;
    }



Chceme po zmazani poslednej polozky v ramci children zoznamu nejakeho konceptu previest nejaku transformaciu
--------------------------------------------------------
- scenar: mame koncept A, ktory obsahuje child koncepty typu B v rozmedzi [0..n]
- po zmazani poslednej polozky chceme previest transformaciu uzlu A na iny druh
- vytvorime preto action map:
action map A_RemoveAllArguments

applicable concept: A

actions:

action DELETE description :
              can execute : (editorContext, node)->boolean {
							  node.arguments.isEmpty;
							}
              execute : (editorContext, node)->void {
						  node<PVarName> newNode = new initialized node<PVarName>();
						  newNode.name.value = node.name.value;

						  node.replace with(newNode);
						  newNode.select[in: editorContext, cell: MOST_RELEVANT, selectionStart: newNode.name.value.length()];
						}

- tento action map v editore pre koncept A vyberieme jeho children typu B a nastavime na ne danu akciu
- pre upresnenie:
	- vsetky child polozky konceptu A boli zmazane
	- mazeme este posledny usek <<...>>
	- az teraz sa aplikuje transformacia
	
- a zial, zda sa, ze inak to ani nejde
- cize pokial potrebujeme transformaciu, pokial napr. zostane prave 1 polozka, je nutne postupovat podla nasledujuceho patternu:
	- rozdelit medzi 2 childov: jeden bude predstavovat prvu polozku a zvysok bude zoznam
	- na zoznam nasadit podobnu akciu, ako je predvedena na priklade vyssie
	- iny sposob, mozno o nieco lepsi, je mat naopak ako prvych n-1 poloziek prvy child, a posledna polozka je druhy child
		- tym sa predide nutnosti odstranovat <<...>> pre prevedenie tranformacie
	

	
Koncept1 obsahuje iny koncept2 ako jedinu child polozku, chceme, aby sa zobrazoval v ctrl + space koncept2 tam, kde ma byt koncept1
--------------------------------------------------------
- majme jednoduchy priklad podla projektu "Experimental"
- root je postupnost "Statement"
- "Statement" moze byt bud deklaracia novej premennej alebo ExpressionStatement
- ExpressionStatement je koncept, ktory obsahuje ako jediny child uzol typu Expression
- Expression je inak samostatny koncept, abstraktny, od ktoreho dedi napr. BinaryExpression, VariableReference a i.
- lenze root nie je posupnost Expression, ale ExpressionStatement prip. deklaracii
- cize aby navrhla kontextova napoveda napr. BinaryExpression na danom mieste, je nutne zadefinovat wrapper
- napr. takto:

default substitute menu for concept ExpressionStatement
  wrap substitute menu(output concept: default)
    menu to wrap default substitute menu for Expression
    handler
      (parentNode, currentTargetNode, link, editorContext, model, pattern, nodeToWrap)->node<ExpressionStatement> {
        node<ExpressionStatement> node = new initialized node<ExpressionStatement>();
        node.expression = nodeToWrap;

        return node;
      }
    <no additional features>


	
Co wrapper dokaze a preco obcas "nefunguje"?
--------------------------------------------------------	
- wrapper, ako hovori nazov, iba obali nejaky existujuci koncept
- predpokladajme situaciu:
- majme koncept A, ktory pripusta ako svoj child iba koncept B
- koncept B obaluje koncept C a to je jeho jediny ucel
- cize chceme v mieste child A, aby nam MPS navrhol akoby koncept C, ale uz obaleny v ramci B
- na to sluzi wrapper
- pokial aj C bol iba abstraktny koncept, bude proste navrhovat na mieste B vsetky konkretne varianty C, co je uzitocne
- nicmenej to nekopiruje defaultne transformacie pre C
- predpokladajme totiz, ze sa niekde ocakava abstraktny koncept C - t.j. je nutne zvolit nejaky z jeho konkretnych
- pre nejaky jeho konkretny je ale nadefinovana specialna tranformacia z C na KonkretnyC
- tato transformacia sa ale nedokaze automaticky zahrnut cez wrapper a je nutne ju naprogramovat pre B znovu
	
	
	
Jak poskytnut vhodnu napovedu v cervenych obdlznickoch?
-------------------------------------------------------
- majme "class <no value> <no value> where"
- chcem namiesto prveho "<no value>" mat "<class>" a namiesto druheho mat "<type variable>"
- pokial ide o abstraktny koncept, ktory je dovodom, ze je ten obdlznicek cerveny, mozno nadefinovat concept editor aj prenho
- v takom pripade vzdy namiesto abstraktneho konceptu bude zobrazeny jeho editor, akurat bude podciarknuty nacerveno, lebo je nekorektny



Jak rozumne pomenovat zdrojovy subor, t.j. samotny model?
(Musim pouzit implements INamedConcept)
-------------------------------------------------------
- pointa je, ze ked mame zdrojove subory v solution, treba ich pomenovat
- ich meno je ale vzdy pevne prepojene s property {name}, ktora je ziskana po implementacii interface-u INamedConcept
	- root koncept musi implementovat dany interface
	- v editore musi byt niekde nastaveny
- INamedConcept ale nie je vzdy dostatocne restriktivny, jak to zmenit?
=> dedit od interface-u INamedConcept
	- ako priklad sa mozno pozriet na IValidIdentifier
		- stlacit ctrl + n
		- napisat "IValidIdentifier"
		- karta "constraints"
		- preklik a inspirovat sa
- dalsia moznost je vyuzit editovatelnu bunku v editore
	- namiesto nej vytovirt bunku "model access"
	- ta ma vlastny getter / setter
	- tieto napojit na pozadovanu property



Nefunguje select novo vytvoreneho uzla v editore
-------------------------------------------------------
Pricin moze byt viacero, ale typicky je to kvoli niecomu takemuto:
  
node.replace with new initialized(PList); 
node.select[in: editorContext, cell: MOST_RELEVANT]; 
- tu je problem ten, ze "node" po replacenuti prestava existovat

=> staci takato obmena kodu:
node<PList> newNode = new initialized node<PList>(); 
node.replace with(newNode); 
newNode.select[in: editorContext, cell: MOST_RELEVANT]; 
	
	
	
Transformacie: text vs. can execute vs. prazdny text
-------------------------------------------------------	
- predpokladajme jednoduchu situaciu:
	- mame 3 koncepty: hey, hi, hello
	- ich aliasy su rovnake, ako mena tychto konceptov
	- v editore su reprezentovane konstantnymi bunkami
	- jednotlive koncepty su potomkami rovnakeho abstraktneho konceptu, cize su zamenitelne
	
Text:
default transformation menu for concept StatementHello 
  section({ side transform : right }) { 
    action 
      text (editorContext, node, model, pattern)->string { 
        "hi"; 
      } 
      can execute <always> 
      execute (editorContext, node, model, pattern)->void { 
        node.replace with new initialized(StatementHi); 
      } 
    ---------- 
    action 
      text (editorContext, node, model, pattern)->string { 
        "hey"; 
      } 
      can execute <always> 
      execute (editorContext, node, model, pattern)->void { 
        node.replace with new initialized(StatementHey); 
      } 
  }
	- primitivna transformacia, pokial nastane niektora z tychto udalosti:
		- napravo od "hello" sa zacne pisat "hi" alebo "hey"
		- napravo od "hello" sa stlaci medzernik a tak sa zacne pisat "hi" alebo "hey"

Prazdny text:
default transformation menu for concept StatementHey 
  section({ side transform : right }) { 
    action 
      text (editorContext, node, model, pattern)->string { 
        ""; 
      } 
      can execute <always> 
      execute (editorContext, node, model, pattern)->void { 
        node.replace with new initialized(Statement).select[in: editorContext, cell: MOST_RELEVANT]; 
      } 
      <no additional features> 
  }
	- po tom, co napravo od konceptu "hey" stlacime medzernik, mozeme zadat alias a defaultne transformacie uz zabezpecia zvysok
		- po tom, co zadame medzernik, sa objavi specialna bunka
		- pokial v ramci toho, co je tato bunka oznacena, cokolvek zadame, prevedie sa transformacia
	- upozornime, ze tu je dolezite, aby v ramci execute bloku bol definovany select na novy abstraktny koncept - musime nechat defaultne transformacie urobit svoju pracu
	- taktiez je nutne zdoraznit, ze musi byt stlaceny medzernik - nestaci len zacat pist "hello" ci "hi" napravo od "hey" ako v prvom pripade

Can execute:
	- je prakticky nepouzitelny
	- nie je nim mozne zabezpecit kontroly patternu, tie musia vychadzat z textu
	- vid naspodku cast "transformacia - can execute - priklady"
	


Kedy sa transformacia neaplikuje hned, ale je ju nutne odkliknut cez enter po zadani textu?
-------------------------------------------------------
=> ked nastane konflikt:
	- napr. jedno trasnformacne menu obsahuje return pattern; a druhe return "a";
	- po zadani "a" ale prejde pre oba (pretoze return pattern; vyhovuje "a")
	- cize sa otvori transformacne menu s polozkami (po zadani ctrl + space), ktore budu miznut, pokial pre niektory z nich sa "can execute" vyhodnoti na false
	- nemusi sa ani otvorit menu s polozkami, ale v momente stisku enter sa vyhodnoti, co vyhovuje a taka transformacia prejde

- pozor na tento pripad:
	- majme nejaku beznu transformaciu napr. po zadani textu "b"
	- potom majme este toto:
	action
	  text (editorContext, node, model, pattern)->string {
		"a";
	  }
	  can execute {
		true;
	  }
	- po napisani "a" sa samozrejme transformacia bezne prevedie
	- nicmenej po napisani "b" sa otvori transformacne menu
	- preco? lebo v tom druhom sme urcili, ze sa transformacia moze spustit kedykolvek, napisanie pismena "a" len otvara menu
	=> riesenie je ponechat can execute <always> a nepisat vlastny query
		- ano, je velky rozdiel medzi tymito dvomi:
		can execute <always> 
	
		can execute {
		  true;
		}
		
	=> co ak ale potrebujeme nejaku podmienku? jak to obist?
		- pouzit "group", ktory disponuje vlastnym condition
		- pod dany "group" zasadit nasu tranformaciu
		- nicmenej nepouzivat dany "can execute"
		
		
		
Jak zabezpecit komplikovanejsiu transformaciu pre nestaticky text?	
-------------------------------------------------------	
- mozno pouzit pattern podla casti "Transformacie znovu: text vs. can execute vs. prazdny text"
- t.j. vratit prazdny text a nechat defaultne transformacie urobit svoje

- inak je mozne vyuzit toto:
	default transformation menu for concept StatementHi 
	  section({ side transform : right }) { 
		action 
		  text (editorContext, node, model, pattern)->string { 
			// Vratime taky string, ktory najviac vyhovuje sucasne napisanemu textu
			list<string> options = new arraylist<string>{"hey", "hello"}; 
			string result = options.get(0); 
			options.forEach({~it => 
			  if (it.startsWith(pattern)) { 
				result = it; 
			  } 
			}); 
			 
			return result; 
		  } 
		  
		  // Can execute je useless, nepouzivat na kontroly patternu
		  can execute <always> 
		  
		  // Exte raz rozhodovanie podla patternu v samotnej transformacii 
		  // (ked uz mame istotu, ze pre napisany text sa transformacia ma naozaj previest)
		  execute (editorContext, node, model, pattern)->void { 
			if (pattern.equals("hey")) { 
			  node.replace with new initialized(StatementHey); 
			} else if (pattern.equals("hello")) { 
			  node.replace with new initialized(StatementHello); 
			} 
		  } 
		  <no additional features> 
	  }
	  
	  

Preco ten predchadzajuci bod obcas nefunguje? t.j. ked obmienam cast text v ramci transformacie, sprava sa neocakavane
-------------------------------------------------------
- typicky, pokial to nefunguje tak, jak by som chcel, je to asi kvoli tomu, ze vraciam nieco uplne ine
- predpokladajme, ze povolujem v ramci text programovo tieto patterny:
	- akakolvek kombinacia znakov * a / taka, ze ich pocet je v patterne rovnaky
- toto sa naprogramuje relativne trivialne, nicmenej co by mohlo zviest, je implementacia typu:
	- pokial je pocet znakov * v patterne rovny /, vrat pattern
	- inak vrat nejaky placeholder, napr. "illegal value"
- problem je, ze jak uz raz vratim placeholder, tak sa zda, ze MPS ma vlastnu internu reprezentaciu casti text, pravdepodobne v podobe trie
	a nechce sa mu vraciat v tomto strome
- cize v momente toho, jak sa vrati "illegal value", uz nikdy nebude mozne dopisat potrebny pocet znakov / alebo * pre to, aby sa vratil 
	pattern, MPS totiz vyhodnotil, ze zhoda neplati a ani platit nebude
- riesenie je namiesto placeholderu vratit pattern appendovany nejakym zhlukom znakov (idealne nieco, co moze platit a je najblizsie
	k sucasnemu patternu z hladiska retazcovej vzdialenosti)
	  
	  

Jak mat jednu transformaciu	pre specificky text a defaultnu transformaciu, pokial je napisane cokolvek ine?
-------------------------------------------------------
- staci takto jednoducho vymenovat transformacie pre specificke texty (moze byt pokojne viacero):
action 
  text (editorContext, node, model, pattern)->string { 
    "hello"; 
  } 
  can execute <always> 
  execute (editorContext, node, model, pattern)->void { 
    ...
  } 
  <no additional features>

- a potom mat defaultnu fallbackovu transformaciu:
action 
  text (editorContext, node, model, pattern)->string { 
    ""; 
  } 
  can execute <always> 
  execute (editorContext, node, model, pattern)->void { 
	...
  } 
  <no additional features>	  
	  
- BTW, poradie nehra rolu
- pokial defaultna transformacia vedie na abstraktny koncept, ktory sa ma este dalej automaticky substituovat, 
	tak este nezabudnut select na novo-vytvoreny uzol:

newNode.arguments.add(argument).select[in: editorContext, cell: MOST_RELEVANT];
	  
	  

transformacia - can execute - priklady, alebo jak chapat jednotlive casti tranformacii
-------------------------------------------------------	
- je najkomplikovanejsi
	default transformation menu for concept StatementHi 
	  section({ side transform : right }) { 
		action 
		  text (editorContext, node, model, pattern)->string { 
			""; 
		  } 
		  can execute (editorContext, node, model, pattern)->boolean { 
			return pattern.equals("hey") || pattern.equals("hi"); 
		  } 
		  execute (editorContext, node, model, pattern)->void { 
			if (pattern.equals("hey")) { 
			  node.replace with new initialized(StatementHey); 
			} else if (pattern.equals("hello")) { 
			  node.replace with new initialized(StatementHello); 
			} 
		  } 
		  <no additional features> 
	  }
- toto vobec nefunguje
	- sice text je udany, ako prazdny, ale v momente stlacenia medzernika podmienka v ramci can execute neplati a teda sa ani nezobrazi nasa specialna bunka
	- vobec nic to nerobi
	- a nesuvisi ani s tym, jak je napisana podmienka v can execute - nefunguje, ani ked sa napise "startsWith", ci ked dame porovnanie na jedine pismeno
	default transformation menu for concept StatementHi 
	  section({ side transform : right }) { 
		action 
		  text (editorContext, node, model, pattern)->string { 
			"hey";
		  } 
		  can execute (editorContext, node, model, pattern)->boolean { 
			pattern.equals("hey"); 
		  } 
		  execute (editorContext, node, model, pattern)->void { 
			node.replace with new initialized(StatementHey); 
		  } 
		  <no additional features> 
	  }
- ani toto nefunguje
	- ani pokial text vracia pattern
	- prakticky ziadna kombinacia
	default transformation menu for concept StatementHi 
	  section({ side transform : right }) { 
		action 
		  text (editorContext, node, model, pattern)->string { 
			"h"; 
		  } 
		  can execute (editorContext, node, model, pattern)->boolean { 
			"hey".startsWith(pattern); 
		  } 
		  execute (editorContext, node, model, pattern)->void { 
			node.replace with new initialized(StatementHey); 
		  } 
		  <no additional features> 
	  }
- toto prevedie transformaciu po napisani "h"
	default transformation menu for concept StatementHi 
	  section({ side transform : right }) { 
		action 
		  text (editorContext, node, model, pattern)->string { 
			pattern; 
		  } 
		  can execute (editorContext, node, model, pattern)->boolean { 
			"hey".startsWith(pattern); 
		  } 
		  execute (editorContext, node, model, pattern)->void { 
			node.replace with new initialized(StatementHey); 
		  } 
		  <no additional features> 
	  }
- tiez sa prevedie okamzite po napisani "h"
- zaver je teda taky, ze pokial sa zacne nieco pisat, kontroluje sa, ci nastala zhoda oproti text
	- prazdny text znamena zhoda oproti medzerniku
	- pattern znamena zhoda oproti akemukolvek textu
- pokial nastane zhoda oproti textu, kontroluje sa can execute a kontroluje sa asi po kazdom pismene
	- pre pismeno "h" plati, ze "hey".startsWith(pattern);
	- zial, pre pismeno "h" neplati, ze "hey".equals(pattern); a uz sa dalej nekontroluje
- pokial can execute plati, automaticky sa prevedie execute
- bohuzial, toto tiez nefunguje:
  execute (editorContext, node, model, pattern)->void { 
    if (pattern.equals("hey")) { 
      node.replace with new initialized(StatementHey); 
    }
- po napisani "h" sa povazuje, ze transformacia nastala a uz sa dalej neriesi (t.j. uz ju dalsie stisky klavesy nevyvolavaju)
- co znamena, ze je to nanic	
	
=> pochopenie jednotlivych poloziek v klasickej transformacii
// action predstavuje jedno tzv. transformacne menu
// t.j. ked sa objavi ponuka pre "ctrl+space", tak to je jedna polozka
// niekedy sa polozky nezobrazia, t.j. niekedy sa len menu automaticky aplikuje
action
  text (editorContext, node, model, pattern)->string {
	// string, ktory ked sa napise, tak sa vyvola tzv. transformacne menu
	"1"
  }
  can execute (editorContext, node, model, pattern)->boolean {
	// vrati, ci mozno aplikovat sucasnu transformaciu
	// nema nic spolocne so stringom vyssie
	// pokial viacere trasnformacne menu vyhodnotia can execute na true, tak sa tranformacia neaplikuje instantne, ale zobrazi menu
	// v ktorom treba odkliknut cez enter (toto oznacujem pojmom "konflikt")
	// pokial tuto transformaciu uz nemozno aplikovat, polozka menu zmizne
	// pripomenme, ze can execute true je nieco ine, nez can execute <<always>>
	// can execute <<always>> de facto znamena, ze okamzite, co nastane zhoda oproti casti text, tak vrati true
	// can execute true znamena, ze trasnformacne menu mozno vyvolat akymkolvek textom a vzdy bude tato trasnformacia povolena 
	// => bude ju mozne zvolit z menu
	true;
  }
  execute (editorContext, node, model, pattern)->void {
	// co sa ma vykonat pre toto transformacne menu
  }
  <no additional features>
  
  

Jak zabezpecit pre urcite koncepty urciteho druhu ine zobrazovanie textu?
Napr. referencovanie z ineho modulu module1.foo() vs. bar() v aktualnom module
-------------------------------------------------------
- editor pre danu vec, ktora ma vyzerat na zaklade kontextu inak, vytvorime takto:
[- ( % myReferencedConcept % -> * R/O model access * ) -]
- myReferencedConcept je referencovany koncept
- * R/O model access * je specialne zobrazenie takehoto konceptu
- treba sa pozriet na inspector
- dole, na spodku, je:
Value:
(editorContext, node)->string { 
  // Nieco, co vracia string (t.j. to, co mame zobrazit)
  node.parent : Container.name + "->" + node.name;
}



Jak zabezpecit, aby sa referencie zobrazovali tak, jak ich cheme my a nie default?
-------------------------------------------------------
- obzvlast je problem pri zobrazovani, pokial nerefenrcujeme INamedConcept, ale iba nejaku property
- docielime tak, ze vytvorime constraint
- pridame toto (v casti presentation naprogramujeme pozadovane zobrazovanie):

link {ref} 
	  referent set handler <none> 
	  scope <default> 
	  presentation (exists, referenceNode, contextNode, containingLink, linkTarget, operationContext, enclosingNode, model, position, contextRole, parameterNode, inEditor, smartReference, visible)->string { 
		return parameterNode.value; 
	  } 

- je nutne podotknut, ze ide o deprecated feature napriek tomu, ze alternativa zatial neexistuje (migration sa nechova spravne),
takze je nutne pridat cast "presentation" kopirovanim



Preco mi neponuka ziadnu referenciu, aj ked evidentne existuju?
-------------------------------------------------------
- dovodov moze byt viacero, napr. zly constraint na scope
- zapeklity dovod je ale pri tejto situacii:
- majme koncept A, ktory je "referencny", t.j. obsahuje len a len referenciu na koncept B [1]
- editor je napr. ( %ref_B% -> {value} )
- pokial nejaky koncept obsahuje A, na mieste A nic neponuka
- dovod moze byt napr. ten, ze A implementuje IDontSubstituteByDefault (alebo skor obsahuje default substitute menu)
- tym padom nevie ponuknut A, a nie ze by nevedel najst B



Jak priradit nejakemu node-u referenciu?
-------------------------------------------------------
- predpokladajme koncept A, ktory obsahuje child typu B a referenciu na typ C
- je jasne, ze child B patri konceptu A, t.j. nech _a1 a _a2 su node-y typu A, potom:
	_a1._b = _a2._b;
- tak tento vyraz vytrhne node-u _a2 jeho child B a priradi ho pod _a1 (a vdaka garbage collection povodny child B 
node-u _a1 zanikne automaticky)
- s referenciami je to ale inak a tam skutocne funguje taketo priradenie
- napr. nech _c1 je node typu C, potom:
	_a1._c = _c1;
	_a2._c = _c1;
- tak potom oba node-y _a1 aj _a2 budu mat referenciu na ten isty node typu C



Jak referencovat nodes z ineho modelu?
-------------------------------------------------------
- predpokladajme, ze mame nejaky model (solution), v nom niekolko Root konceptov (predstavuju 
akoby samostatne moduly, pricom spolu tvoria akoby jeden package)
- Root koncept je proste korenovy koncept, ktory obsahuje:
	- B[1] - jednoduchy koncept implementujuci INamedConcept interface
	- C[0..1] - referencia na koncept B
- v ramci tohto modelu sa jednotlive koncepty C mozu odkazovat na koncepty B z cudzich Root konceptov
(ale stale v ramci toho isteho modelu)
- co ak ale mame uplne novy model, jak sa z jeho Root konceptu mozno odkazovat na koncepty B z ineho modelu?

=> alt + enter pri oznacenom modeli
- Used Languages: dany jazyk, ktory ma pouzivat
- Dependencies: odkazeme na model, z ktoreho chceme referencovat



Scope - jak zabezpecit, aby sa referencne koncepty nebrali z ineho modelu, nez aktualneho?
-------------------------------------------------------
- predpokladajme root koncept Calculator
- predpokladajme, ze v nom mame definovane koncepty InputField
- predpokladajme, ze v nom mame taktiez definovane koncepty, ktore referencuju InputField
- chceme obmedzenie, aby sa referencie brali len z daneho root Calculator-u, kde aj boli definovane

- vziat referencny koncept na InputField a prejst do contraints
treba na constraints zlozku -> alt + enter -> dependencies -> jetbrains.mps.scope
treba taktiez na constraints zlozku -> alt + enter -> used languages -> jetbrains.mps.devkit.language-design

link {iputField}
  referent set handler <none>
  scope (referenceNode, contextNode, containmentLink, position, linkTarget, operationContext)->Scope {
    SimpleRoleScope.forNamedElements(contextNode.ancestor<concept = Calculator>, link/Calculator : inputFields/);
}

- predpokladajme teraz, ze mame root concept Calculators, ktory obsahuje Calculator (ktory uz nemoze byt root)
- chceme obmedzit, ze umoznime referencovat len z ineho Calculator-u, nez zo svojho
- priklad riesenia je napr. takyto:
SimpleRoleScope.forNamedElements(
	contextNode.ancestor<concept = Calculator>.siblings.get(0), link/Calculator : inputFields/);

- teraz ako umoznit referenciu InputField-ov zo vsetkych ostatnych, len nie sucasneho, Calculator-ov?
CompositeScope cs = new CompositeScope(); 
foreach calculator in contextNode.ancestor<concept = Calculators>.calculators { 
  if (calculator != contextNode.ancestor<concept = Calculator>) { 
    cs.addScope(SimpleRoleScope.forNamedElements(calculator, link/Calculator : inputFields/)); 
  } 
} 
 
return cs;



Scope - jak na priklad so Scope blokmi?
-------------------------------------------------------
- predpokladajme situaciu:
- mame root koncept Root, ktory obsahuje:
	- A[0..n]
	- C[0..n]
	- B[0..n]
- koncept A obsahuje:
	- C[0..n]
	- B[0..n]
- koncept C je jednoducha premenna (INamedConcept)
- koncept B obsahuje referenciu na koncept C

- chceme, aby B vedel odkazovat iba na koncepty C v ramci svojho bloku
	- t.j. pokial je obsiahnuty v koncepte A, tak na tie C, ktore spadaju pod toto A a zaroven na C pod Root
	- pokial je obsiahnuty v koncepte Root, tak len na C definovane v tomto Root koncepte
	
- funguje nasledujuci pattern:
- koncept B implementuje nasledujuci constraint na referenciu na C:
link {C} 
  referent set handler <none> 
  scope (referenceNode, contextNode, containmentLink, position, linkTarget, operationContext)->Scope { 
    return contextNode.ancestor<concept = ScopeProvider>.getScope(concept/C/, contextNode); 
  } 
  - ziska Scope z prveho ancestor-a, ktory implementuje ScopeProvider

- koncept A aj koncept Root musia implementovat interface ScopeProvider
- v behavior konceptu Root pretazime (ctrl + o) metodu getScope:

public Scope getScope(concept<> kind, node<> child) 
  overrides ScopeProvider.getScope { 
  if (kind.isSubConceptOf(C)) { return SimpleRoleScope.forNamedElements(this, link/Root : C/); } 
  return null; 
}                                                                                                                                                                                                           
- toto hovori, ze pokial sa dotazujeme na koncepty C (kind.isSubConceptOf(C)), tak vratime tie,
ktore mame priamo pod sebou (SimpleRoleScope.forNamedElements(this, link/Root : C/);)

- v behavior konceptu A tiez pretazime (ctrl + o) metodu getScope:
public Scope getScope(concept<> kind, node<> child) 
  overrides ScopeProvider.getScope { 
  CompositeScope result = new CompositeScope(); 
  result.addScope(parent scope); 
  if (kind.isSubConceptOf(C) && come from B) { 
    result.addScope(SimpleRoleScope.forNamedElements(this, link/A : C/));
  }

  return result; 
}
- toto hovori, ze pokial sa dotazujeme na koncepty C (kind.isSubConceptOf(C)) a zaroven sa na ne dotazujeme
z child konceptu B (come from B - pozor, toto je dolezite, inak by koncept B definovany na urovni root
mohol tiez nadobudnut referencie z bloku A, co nechceme pripustit), tak vratime tie, ktore su definovane 
na nasej urovni + vsetky delegujeme koncept na rodica
	- parent scope vracia vlastne akoby "ancestor scope", t.j. deleguje na vyssi ScopeProvider
	- dokonca to funguje aj vtedy, ked A neobsahuje B priamo, ale cez nejakych prostrednikov
		- ("come from B" je link na child, z ktoreho moze prist, nie link na koncept)



Preco MPS vyhadzuje chybu pri scope-och, ze nemoze pretypovat node na INamedConcept?
Preco pri non-INamedConcept sa scoping sprava divne, t.j. nevracia potrebne nodes?
-------------------------------------------------------
- pravdepodobne bola pouzita metoda "SimpleRoleScope.forNamedElements"
- aby bolo jasne, "SimpleRoleScope.forNamedElements" vlastne vytvara novy scope, ktory je typu SimpleRoleScope
	- jeho definicia, jak je naprogramovany, sa da pozriet v behavioru
	- da sa naprogramovat aj uplne vlastny scope
- lenze forNamedElements vytvori instanciu SimpleRoleScope taku, kde ocakava, ze dany node bude typu INamedConcept
	- "for named", t.j. pre tie, co implementuju INamedConcept
- cize staci len vytvorit novu instanciu takto:

	return new SimpleRoleScope(this, link/Subdefinition : declarations/) { 
	  public string getName(node<> child) { 
		child : Declaration.name; 
	  } 
	};

- (pozor, obcas nevyhadzuje vynimku a potom sa blbo debuguje, ze preco scope nie je korektne obmedzeny)

	
	
Scope - jak na komplikovanejsi priklad?
-------------------------------------------------------
- predpokladajme situaciu:
- mame root koncept Root, ktory obsahuje:
	- Definition [0..n]
- koncept Definition obsahuje:
	- Declaration [1..n]
	- Subdefinition [0..n]
	- ObscureReference [0..n]
- koncept Subdefinition obsahuje:
	- Declaration [1..n]
- koncept ObscureReference obsahuje:
	- Reference [1]
	
- koncept Declaration je jednoducha premenna (INamedConcept)
- koncept Reference ma odkazovat na Declaration, takto:
	- (za blok povazujem Definition)
	- vie referencovat vsetky Declaration zo vsetkych Subdefinition, ktore su v tom istom bloku, ako je on
	- vie referencovat vsetky Declaration zo vsetkych Definition v ramci Root (ale uz nie nutne Declaration v ich jednotlivych Subdefinition)
	
- narozdiel od predosleho prikladu je to tazsie, pretoze Scope vytvara vlastne Definition, ale potrebuje delegovat aj na surodencov a hrozia cykly
- (tu jednoznacne je nutne pouzit "come from" syntakticky konstrukt)
- pattern, ktory by mal fungovat, je nasledujuci:

- vzhladom na to, ze v Subdefinition existuje Declaration, tak Subdefinition je ScopeProvider
- Definition je tiez z rovnakych dovodov ScopeProvider
- pretoze v ramci Root existuju Definition, ktore poskytuju Scope, aj Root je ScopeProvider
- ak by boli na ceste od Root ku Definition dalsie koncepty, tiez musia poskytovat Scope

- pattern hovori, ze sa od Root musime dostat ku vsetkych nodes, ktore maju byt v Root-e viditelne
- toto plati pre kazdy podstrom
- cize Scope pre urcity druh konceptov sa ziada od Root-u, ten deleguje ich vytvaranie na vsetky children, ktore su typu ScopeProvider, a tie deleguju 
dalej
	- tvorime teda Scope zhora nadol
	
- tvorenie Scope-u delegujeme zhora nadol az dokym nedojdeme po koncept, ktory naozaj vie poskytnut potrebne nodes daneho druhu
	- pokial ide o pozadovany druh (kontrola "kind" argumentu), vrati Scope cez "forNamedElements" metodu
	- pokial nejde, dalej deleguje dole na nizsie urovne stromu, prip. vrati prazdny Scope
	
- potom vsak mame specialne pripady, ked je nutne poskytnut nieco,
co nemozno poskytnut do Scope-u, pokial by poziadavok prisiel zhora
	- napr. pre ObscureReference vnutri Definition musi poskytnut Scope, ktory zahrna aj Declaration zo Subdefinition
- pri takychto pripadoch je nutne cez "come from" osetrit, ci poziadavok prichadza z korektneho node a pokial ano, tak vratit:
	- "specialny" scope pre tento node
	- zaroven delegovat vytvorenie scope-u na parenta
=> tym padom kazdy koncept, ktory je ScopeProvider, sa musi najprv pozriet, ci poziadavok na vytvorenie Scope neprisiel od potomka a ak ano, 
len deleguje vytvorenie Scope na najvyssieho predka, ktory spusti vytvorenie Scope zhora nadol

	// getScope v ramci Definition
	public Scope getScope(concept<> kind, node<> child) overrides ScopeProvider.getScope { 
	  CompositeScope cs = new CompositeScope(); 
	  if (kind.isSubConceptOf(Declaration)) { 
		// pokial poziadavok prisiel z potomka, deleguje Scope na parenta
		if (come from references) { 
		  cs.addScope(parent scope); 
		   
		  // + "vsuvka", osetrenie pre specialny pripad (pre potomka je scope rozsiahlejsi)
		  foreach subdefinition in this.subdefinitions { 
			cs.addScope(subdefinition.getScope(kind, child)); 
		  } 
		// Inak to znamena, ze tvorime Scope zhora nadol
		} else {
		  // sme zaroven poskytovatelia daneho druhu node-ov, takze ich musime vratit
		  cs.addScope(SimpleRoleScope.forNamedElements(this, link/Definition : declarations/)); 
		  
		  // pokial by existoval nejaky child, ktory standardne ma vraciat scope, tak by sme tu este museli delegovat nanho
		} 
	  } 
	   
	  return cs;
	}

Zhrnutie:
- na ceste od Root ku poskytovatelom Scope-u musi byt cesta z konceptov, z ktorych kazdy je ScopeProvider
- kazdy z tychto konceptov sa pozrie, ci poziadavok na Scope nahodou neprisiel z niektoreho z jeho children:
	- ak nie, deleguje vytvaranie Scope-u na potomkov
	- ak ano, deleguje vytvaranie Scope-u na rodica
		- tu mozno vsuvat specialne pripady, pokial ma mat taky potomok rozsiahlejsi scope, alebo narok na nodes, ktore by inak nevidel
- pokial sme v konecnom koncepte, ktory obsahuje podla "kind" premennej
pozadovane nodes:
	- stale sa spravame ako ostatne koncepty "po ceste", t.j. delegujeme bud na rodica alebo potomkov
	- nicmenej pokial prisiel poziadavok od rodica, tak pokial podla "kind" je to to, co sa chce po nas, tak to zaroven aj vratime cez 
	"forNamedElements", a potom (este) delegujeme na potomkov
- aby sme si ujasnili, delegovanie vytvarania Scope-u na rodica az ku korenu vlastne hovori, ze pre koren prisiel poziadavok na Scope od potomka
a teda musi delegovat vytvorenie Scope-u na rodica (ale ziaden dalsi uz nie je, cize ho len jednoducho vrati) a navyse este musi specialne obsluzit
cez "vsuvku", t.j. popridava Scope od vsetkych, od ktorych by mal
	- nicmenej to znamena, ze moze delegovat vytvaranie Scope na toho isteho potomka, odkial mu poziadavok prisiel - preto takyto pattern, inak by sme
	sa dostali ku cyklom
	

	
Jak vytvorit triedu pri programovani v behaviour?
-------------------------------------------------------
- pravy klik na behavior -> New -> j.mps.baseLanguage -> class / enum / interface