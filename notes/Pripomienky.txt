- Dostupne operatory:
	#  $  %  &  *  +  .  /  <  =  >  ?  @  \  ^  |  -  ~ :
	- problematicka je bodka a dvojbodka

- Can be child:
	- v priklade s bodkovou notaciou, co bolo rozsirenie Javy
	- mali sme koncepty, ktore boli extension konceptu Expression, specialne potomkami abstraktneho konceptu "AddressReference"
	- na nich sme chceli povolit cez bodkovu notaciu len 2 specialne vyhradene koncepty, ktore dedili od konceptu, ktory mal nasledujuci constraint:
	(can be child)
	(childConcept, node, link, parentNode, operationContext)->boolean {
	  // DotExpression uz existujuci koncept v Jave
	  parentNode as DotExpression.operand.isInstanceOf(AddressReference);
	}

- Blbne substitucia integeru na double:
	- 17.1
	- bodku chape ako snahu o zadanie operatoru
	- lenze... inak to asi nejde, priklad:
	[1, 2, 3 .. 10]
	- tu sa bodka musi chapat ako snahu zadat operator, ale je to viacznacne
	- MPS engine neumoznuje mat obidve moznosti, nehovoriac o tom, ze urcite vlastne operatory tiez mozu
	zacinat bodkou, napr.:
	1 .:- 7
	- cize jak to rozlisit? nijak, pridali sme proste intention, pokial uzivatel chce zmenit integer na double

- Pattern v pripade scopes:
	- ...je komplikovany
	- zakladny pattern je ten popisany v MPS-HowTo, ale je rozsireny, pretoze napr. PatternFunction nevie, ci rodic ziadal o scope pre seba
	(cize by zahrnul aj premenne) alebo len poskytuje navonok vyssie (cize by zahrnul len nazov funkcie)
		=> pridane este "restriction"
	- celkovo sa opiera o interface DCScopeProvider
	- inak scope moze vzdy podla mojho patternu poskytnut iba rodic, node nikdy neposkytuje "sam seba" do scope-u
		- toto je kvoli tomu, ze vzdy node, ktory sa ma zaradit do scopeu, drzi nejaky rodic, ktory rozhoduje o tom, ci mu "ma povolit
		"vyjst von alebo nie
		- samotny node nema totiz informaciu, ci sa ma zaradit, alebo nie (pre samotnu premennu nie je jasne, ci sa ma zahrnut do scopeu, alebo nie,
		pretoze zavisi od toho, kde sa prave nachadza - co ale ona sama nevie)

- Function-definition: umoznit zadavanie funkcie v ramci 1 blok
	Definovane v tychto transformacnych menu:
	- default transformation menu for FDAVarName
	- transformation menu PatternArgument_SetFunctionDefinitionToAssignmentOrGuard for concept PatternArgument

- Pozor, niekedy vyhodi NullPointerException aj ked ide o neinicializovany string (Bug v MPS), cize potom treba kontrolovat cez mystring.isEmpty

- AnnotationItem pre operator ma tieto nadefinovane akcie:
	- default substitute menu for concept AnnotationItem
	- transformation menu FDABracket_TransformWhenInsideBrackets for concept FDABracket

- Ma OperatorReference dedit od Termu a preco? dtto pre VariableReference?
	- ano, pretoze OperatorReference aj VariableReference maju postavenie PrimaryExpression,
	t.j. musi byt sposob, ako na ne napojit transformaciu sprava pre pridanie noveho argumentu
	pre aplikaciu funkcie, operatoru a pod.

- Referencny koncept na PVarName referencuje jak premenne, tak nazvy funkcii

- PatternConstructor - takato definicia, kupodivu, funguje:
	data ZZ = AA Int | BB Int
	(aa, bb) = (1, 2)
	(AA zz, AA xx) = (AA 10, AA 20)
	- takze PatternConstructor musi poskytovat svoj scope navonok

- Jak sa urobil scope pre Patterns:
	- vsetky definicie typu (x, y, z) = (1, 2, 3) poskytuju vsetky svoje premenne navonok
	- neplati len pre f x y z = x+y+z kde je navonok poskytovana len "premenna" f (analogicky operatory)
	- rozlisene cez "restriction" parameter v ramci DCScopeProvider

- Proces pre OperatorApplication:
	- nadefinovat referencny koncept
		- musi mat udany spravne scope + presentation
		- ma nadefinovanu funkciu "findAndSetReference"
	- je koncept OperatorApplication
		- dedi od GenericApplication, tym padom automaticky pocita s tym, ze ma 0..n argumentov typu PrimaryExpression
		- je IDontSubstituteByDefault, teda nenapoveda automaticky v ctrl + space
		- obsahuje PEOperatorReference
			- nikto dalsi neobsahuje ani nepracuje s PEOperatorReference
			- PEOperatorReference je typu PrimaryExpression
			- obsahuje jediny child, OperatorReference[1]
			- implementuje IDontSubstituteByDefault
			- v editore obaluje do zatvoriek OperatorReference, t.j. [> ( % operator % ) <]
			- preco ho vlastne obsahuje?
				- pretoze OperatorApplication dedi od GenericApplication co znamena, ze sa nan vztahuju transformacie napravo, ktore pridavaju
				dalsie PrimaryExpressions
				- dovod je totiz ten, ze samotny koncept OperatorReference nie je typu PrimaryExpression a teda automaticke transformacie napravo
				sa pren nevztahuju
				- tu sa vsak dost spolieha na to, ze existuje konstantna bunka v editore, ktora to takto umoznuje editovat, inak by OperatorReference
				skutocne musel dedit od PrimaryExpression...
			- na PrimaryExpression je naviazana defaultna transformacia, ze pokial sa napravo od nej zacne nieco pisat a je v ramci
				"GenericApplication", tak je mozne pridat dalsi argument
			- PEOperatorReference je typu PrimaryExpression
			- do PrimaryExpression boli includovane transformacie z rodica, t.j. GenericApplication
			- v analogickom pripade pre VariableReference je nutne nadefinovat default transformation pre VariableReference tak, ze includuje
				default transformation od PrimaryExpression (pokial je teda v rodicovi, ktory je typu PrimaryExpression, co je v nasom pripade
				PEVariableReference)
	- default substitute menu for concept TopExpression
		- (pri zadavani noveho TopExpression)
		- pokial si budeme v momente zadavania textu isti, ze uz ide len o dany OperatorApplication, tak spustime substituciu
			- v pripade operatoru je to jednoduche, pretoze staci, ze zadany text zacina na nejaky z operatorovych symbolov
		- nasledne ziskame vsetky dostupne referencie (napr. podla scope-u) a zavolame na novo-vytvorenom node findAndSetReference
			- v podstate len predame najblizsi node, pre ktory by mal byt rovnaky scope
			- tu sa teoreticky mozu objavit problemy, cize najprv je nutne uzol do stromu zaradit a az potom zavolat danu metodu, pokial to ide
				- v pripade substitucie je to horsie, ale aj v tomto pripade sme v nejakom node, ktory je korektne v strome umiestneny
	- akcii je kazdopadne viacero - treba zvazit vsade tam, kde sa dany OperatorReference vyskytuje
	- wrapper pre kontextovu napovedu:
		default substitution menu for concept FunctionApplication
			wrap substitute menu(output concept: default)
			// (tu variable reference a nie PEVariableReference)
			menu to wrap default substitute menu for VariableReference
			handler
				(parentNode, currentTargetNode, link, editorContext, model, pattern, nodeToWrap)->node<PLiteral> {
					// Display context help for referentiable variables and functions
					node<FunctionApplication> node = new initialized node<FunctionApplication>();
					node.function.variable = nodeToWrap;

					return node;
				}
			<no additional features>

- Pripomenme, ze definicia typu: ff = "0" je definicia konstantnej funkcie a jej PatternWrapper nalavo neobsahuje PatternFunction z toho dovodu,
	ze skutocne nejde o funkciu, ale o premennu
	- vid analogiu voci (aa, bb, cc) = (1, 2, 3), t.j. ide o tuple premennych

- Povodne sa nereferencovalo cez kontextovu napovedu, ale rovnako, ako operatory:
	create node (parentNode, currentTargetNode, link, editorContext, model, pattern)->node<TopExpression> {
	  // Substitute to FunctionApplication
	  node<FunctionApplication> fa = new initialized node<FunctionApplication>();
	  fa.function.variable.findAndSetReference(currentTargetNode, pattern);
	  return fa;
	}
	selection (parentNode, link, editorContext, model, pattern, createdNode)->void {
	  EditorSelectVariableReference.Select(createdNode : FunctionApplication.function.variable, editorContext, pattern);
	}
	matching text (parentNode, currentTargetNode, link, editorContext, model, pattern)->string {
	  return pattern;
	}
	can substitute (parentNode, currentTargetNode, link, editorContext, model, pattern, strictly)->boolean {
	  return pattern.isNotEmpty && pattern.matches(concept/NodeVARID/.getPattern());
	}
	- t.j. pri zacati pissania nasiel prvu zhodu a tu pouzil

- Export a import modulu:
	- BTW, upozornime, ze instancie sa vzdy importuju, ci sa nam to paci alebo nie
	- inak je asi mozne pouzivat bodkovu operaciu aj inak, nez je tu znazornena, ale nebudeme sa tymito pripadmi zaoberat (spisat do diplomky; uz by toho bolo vela)
	- oddelene kolkokolvek bodkami si chce
	- posledna polozka je meno modulu, ktore zacina striktne velkym pismenom
	- pri exporte:
		- mozno exportovat vsetko, pokial neuvadzame zatvorku
		module MyModule where

		- je mozne uviest zatvorku a vymenovat polozky pre export
		module MyModule (MyType, MyClass, myFunc1) where
			- export naimportovanych poloziek + reexport seba
			module AnotherBigModule (module Data.Set, module AnotherBigModule) where
			import Data.Set
			import Data.Char

	- pri importe:
		- import vsetkeho
		import frege.data.List
			- nie je nutne odkazovanie cez meno, staci rovno referencovat
			import Prelude.Math
			circumference r = 2 * pi * r

		- import len vymenovanych poloziek
		import learnyou.chapter14.TakingAWalk (Tree, Direction, freeTree, **, !!, Read1, Read2(), Read3(readsPrec, readList), Lexeme(...))
			-- Read1 je trieda, Read2() tiez, ale hovori, ze importuj triedu, ale nie jej funkcie, Read3 importuje konkretne funkcie triedy
			-- Lexeme je datatyp a importujeme aj vsetky jeho konstruktory,
			import frege.data.Traversable (sequenceA)
			example2 = sequenceA [ getLine, getLine, getLine ]

		- omport vsetkeho okrem "isControl" a "isMark"
		import Data.Char hiding (isControl, isMark)
			- v tomto pripade sa tiez neodkazujeme cez "Char", ale rovno pouzivame funkcie, podobne ako v predchadzajucom pripade

		- odkazovanie cez ine meno
		import learnyou.chapter07.geometry.Sphere as Sph ()
		f = Sph.volume 2

		- import prazdnej zatvorky
		import frege.prelude.Math ()
		surface (Circle _ r) = Math.pi * r ^ 2
			- dalsie priklady:
			import learnyou.chapter07.geometry.Sphere ()
			println $ Sphere.volume 2

- Pozor, je mozne, ze vzniknu viacere referencie na tu istu vec:
	module mymodule.Exemplar (aa, awesomeFunction, ++, -+-, module mymodule.Exemplar)
	- tym, ze reexportujeme seba a aj jednotlive dielce, vznikli na tie dielce viacere referencie
	- toto by bolo treba nejak osetrit, ale vzhladom na to, ze nejde o uplne syntakticky nespravnu vec, asi sa tym nebudem zaoberat
	- zaroven neviem, ci je mozne exportovat dielce z inych modulov, t.j. ci prejde toto:
	module mymodule.Exemplar (awesomeFunction, Math.pi)
	import frege.prelude.Math ()
	- ale tiez sa mi tym nechce zaoberat
		- nicmenej pokial by to nebolo v poriadku, jedine, co treba, je v tejto casti v Skeleton behaviour:
		// For module we have to provide this module's scope only and nothing else (i.e. stuff from import must be empty)
		return this.getPublicScope(kind, child, this, "module");
		- zmenit restriction naspat na "public"
		- prevenciu cyklickej referencie si zabezpecuju jednotlive module koncepty sami

- Jak je referencovanie poloziek inych modulov poriesene teraz:
	- import koncept je poskytovatelom Scope-u (DCScopeProvider), pretoze nim su urcene dalsie polozky z modulov, ktore importuje
	- module nie je poskytovatelom Scope-u, ale implementuje metodu getScopeForImport(concept<> kind, node<> child)
		- nie je beznym poskytovatelom Scope-u, pretoze sam o sebe nic neposkytuje - funkcie, operatory a pod. poskytuje Skeleton
		- on len vie, co moze byt exportovatelne (t.j. referencovatelne z inych modulov)
		- preto trochu zmena interface-u v tomto konkretnom pripade
	- pretoze module potrebuje delegovat vytvorenie Scope-u na Skeleton, vola na nom getScope...
		- ...az na to, ze takto jednoducho by to sposobilo cyklus
		- (zavola Skeleton, ktory zavola import, ktory zavola module, ktory zavola Skeleton, ...)
		- zaroven by to ani nebolo spravne, pretoze "modul" vracia len scope sameho seba
			module frege.prelude.Math
			module frege.prelude.Math (pi, sqrt)
			module frege.prelude.Math (module Math, module List)
				- az tu vracia nieco viac, nez len svoj modul - vracia aj importovany modul
		- cize v zavislosti od toho, ci obsahuje nejake polozky (ma definovanu "zatvorku") alebo nie, podla toho vytvara scope
		- kvoli tomu vznikol novy restriction = "module", ktory import koncept ignoruje (import vrati scope iba pre "public")

- Bola tam chyba, ze niektore veci referencovalo viackrat:
	- zda sa, ze len v tomto pripade: ff = ff
	- t.j. ked mame funkciu bez argumentov a referencujeme ju sprava, tak nam ju ponukne viackrat
	- je to evidentne kvoli tomu, ze pre plozky vpravo sa tvori scope 2x:
		- raz sa berie "public" scope, t.j. nazvy funkcii
		- potom sa berie "variables" scope, t.j. premenne (a to len v pripade, ze sa pokusame referencovat sprava v definicii funkcie)
	- problem vznikne, ked veci, ktore bezne sluzia ako "variables", su pouzite na definovanie konstantnych funkcii:
		[a, b, c] = [1, 2, 3 + b]
		ff [a, b, c] = a + b + c
	- cize treba sa pozriet, ci existuje ako ancestor PatternFunction a pokial existuje, tak urcite pre napr. PList, PTuple a pod. sme
	na pravej strane, t.j. mozeme vratit scope len ak je restriction = "variables"

- Riesenie pravidiel pre import
	- pripomienka pravidiel prefixovania:
		- moze a nemusi prefixovat cez Math:
		import frege.prelude.Math
		- moze a nemusi prefixovat cez MM:
		import frege.prelude.Math as MM
		- musi prefixovat vsetko:
		import frege.prelude.Math ()
		- musi prefixovat vsetko, co nie je sqrt, cez MM:
		import frege.prelude.Math as MM (sqrt)
		- musi prefixovat sqrt ale moze a nemusi zvysok:
		import frege.prelude.Math hiding (sqrt)
	- koncept import ma 2 metody:
		- getWholeImportedScope
			- import Math (pi, sqrt) by tu vratil vsetko
		- getVisibleImportedScopes
			- import Math (pi, sqrt) by tu vratil len pi a sqrt
	- pre referencovanie su podstatne oba
	- ImportedEntityApplication je EntityApplication pre referencovanie len danej casti z nejakeho importu
		- napr. "Math."
		- za bodkou mozno pouzit len nodes, ktore su referencovane z Math
		- vyriesene trikom, ze ImportedEntityApplication poskytuje scope specialne:
		public Scope getScope(concept<> kind, node<> child) overrides ScopeProvider.getScope {
		  if (come from import) {
			// For referencing imports, provide the scope of imports themselves (by delegating to parent)
			return parent scope;
		  }

		  // Otherwise we provide only the scope of the imported modules
		  // ('come from' does not work here since the node may not even be created yet - we are using wrapper substitution)
		  return this.import.ref.getWholeImportedScope(kind, child);
		}
		- cize vrati akymkolvek detom len scope z importu (a na nom zavola tu metodu getWholeImportedScope)
	- pozor, bolo nutne upravit constraints pre referencovane nodes, ako napr. VariableReference:
		if (contextNode.isInstanceOf(ScopeProvider)) { 
		  return contextNode : ScopeProvider.getScope(concept/PVarName/, contextNode); 
		} 
		return contextNode.ancestor<concept = ScopeProvider>.getScope(concept/PVarName/, contextNode);
		- totizto contextNode niekedy moze mat povahu parenta a niekedy byt samostnym nodeom, ktory obsahuje danu referenciu, preto takto
	
- Starsia pripomienka: premenne a nazvy funkcii - nejde rozumne oddelit, pretoze mame aj definicie
	-konstantnych funkcii, ktore sa podobaju na definiciu premennych
	(x, y, z) = (1, 2, 3)
	- je nutne vsade, kde mame specialne function-definition, urcit, ze meno funkcie je vlastne PVarName
		- zaroven toto mohlo sposobit neprijemny ripple effect, takze pozor
		
- Jak je to s bodkovou notaciou v MPS Java:
	- mame abstraktny Expression
	- z neho dedi aj DotExpression, ktory obsahuje:
		- operand - typu expression
		- operation - typu IOperation
			- operation nie je vzdy Expression, preto musi byt ten typ volnejsi
	- na Expression je transformacia, ze po napisani bodky sa ma previest transformacia Expression na DotExpression
	- zaroven na DotExpression je action map na Expression za bodkou:
		if (node.operation.concept.isExactly(# concept/AbstractOperation/)) {
		  node.replace with(node.operand);
		} else {
		  node.operation = new node<AbstractOperation>();
		}
		- cize pokial je uz prazdna ta bunka, tak sa ma spatne nahradit jednoduchym expression
		
- Aplikacia funkcie, operatoru, atd.:
	- podla gramatiky vieme, ze musi ist o primary+
	- na zaciatku vsak nema zmysel uvazovat tokeny typu cislo a pod.
		- napr. 7 1 3 nedava zmysel, ze by 1 a 3 boli argumenty ku funkcii 7
		- cize ma zmysel uvazovat len obmedzenu skupinu aplikacii (operatoru, funkcie, atd)
	- cize napravo od primary je mozne pridat dalsie primary
	- a ma to fungovat iba, pokial sme uz v nejakej aplikacii
		- t.j. pre pripad 7 asi nedava zmysel umoznit pridat dalsi primary (t.j. v nasom pripade 1 a 3)
	- cize prvy clen v ramci aplikacii musi byt tiez primary, aby sme lahko odpropagovali uz raz nadefinovane akcie transformacie
	
- Zlepsenie pridavania operatorov pri definovani funkcie:
	- v MPS plati, ze mame napr. dva operatory, z ktorych jeden je prefix druheho a je teda ambiguita:
		boolean b1 = true & true
		boolean b2 = true && true
	- ked zacnem pisat &, tak este nevie, ci ma previest transformaciu, cize caka
	- nicmenej, ked napisem &t tak je jasne, ze "t" sa nevztahuje k danemu operatoru a prevedie to
	- normalne sa to programuje tak, ze mame transformacne menu s textom "&" pre prvy operator a potom s textom "&&" pre druhy operator
		- neda sa vratit v casti "text" v transformaciach list stringov, zial
	- a pokial su operatory totalne arbitrarne (a mozu dynamicky pribudat), tak to velmi jednoducho nejde...
	=> privitajme hack storocia:
		- "text" je funkcia zavisla na zadanom pattern-e, cize mozno spravit toto:
		- majme napr. momentalne definovane operatory "++", "-+-"
		- cize pattern musi vraciat, pokial uzivatel napisal:
			- "+", tak vratime "++"
			- "++", tak vratime "++" a transformacia sa vdaka presnej zhode hned prevedie
			- "-", tak vratime "-+-"
			- "--", tak vratime nieco, co nezacina na --, napr. "illegal pattern"
			- kedze je "--" nie je prefixom ku "illegal pattern", tak sa nam toto slovo v transformacnom menu nezobrazi a nejde previest ziadnu 
			transformaciu, cize takto je to v poriadku
		- nicmenej, pokial mame definovane operatory "+", "++" a "-+-", nevieme, ci pri napisani "+" mame vratit "+" alebo "++"
		- cize riesenie je nasledujuce:
			- vytvorit este druhu akciu, ktora je uplne identicka tej prvej, ale vrati vzdy iny pattern, nez ta prva, v casti "text"
			- cize ked uzivatel napise "+", tak v prvej vratime "+" a v druhej "++"
			- tymto vynutime ambiguity a dokym uzivatel nenapise nieco ine, napr. "+1", alebo "++", tak sa transformacia nevykona
			- v pripade napisania "-" prva akcia musi vratit "-+-" a druha musi vratit "illegal pattern", aby naopak k ambiguite nedoslo (pretoze 
			ziadna nie je)
			- takto vynutime spravanie podobne, ako v pripade beznej Javy implementovanej v MPS
			
- Pozor, uz sa mi viackrat stalo, ze mi vratilo null, aj ked to nebolo mozne...
	- davat pozor, ked vyvolam kotnextovu napovedu, napr. "this" moze znamenat az 3 rozne veci, pricom iba jedna z nich je "this node"
			
- Implicitne definicie:
	- je nutne spravit mydef = "!!implicit"!!implicit a konverzia prebehne sama
	- riesene je importovanie cez triedu Libraries
	- zial, v momente konstrukcie root node Skeleton este nie je mozne sa odkazat na model, cize pouzivame lateConstructor pattern
		- namapujeme na nejaku zmenu update() metodu (typicky po nejakom zasahu uzivatela)
		- ta sa prevedie iba pokial sa uz raz nepreviedla
	- inak import ako koncept ma property hidden a v ramci editoru pouzivame cast "filter", kde odfiltrujeme tie, ktore su takto nastavene
		- defaultne je hidden samozrejme false
		
- Pozorovanie ohladom nestandardneho spravania sa editoru:
	- standardny projekt nepotrebuje nastavenie odsadeni a vsetko robi samostatne; akurat pokial separator je |, tak sa aj tak prikloni 
	k lavemu operandu a treba nastavit, aby bol vlastne " |"
		- cize vlastne tvorim "Part1| Part2| Part3" namiesto "Part1 | Part2 | Part3"
		
	Statement s2 = child1 | child2 | child3 [END]
	- pokial [END] patri k vlastnikovi skupiny deti child1, child2 a child3, tak enter tesne pred [END] a tesne za child3 prida novy child
	do nadradeneho rodica
	
	Statement s1 = static | static		-- tu ked stlacim enter, tak pridam novy "static"
	Statement s2 = static         		-- tu ked stlacim enter, idem na dalsi riadok, lebo som posledny
	- a naozaj, pre data mi to skutocne funguje!
	- pre BinExy mi to naopak trochu blbne, ale mame tam tie intentions, takze by to malo ist aj bez toho
	
- Pripomienka pravidiel pre fixity:
	- A fixity declaration can only occur in the same sequence of declarations as the declaration of the operator itself
	- If no fixity declaration is given for a particular operator, it defaults to infixl 9
	- At most one fixity declaration may be given for any operator
		- cize moze byt len v ramci svojho modulu, cize je nutne upravit scope
	
- Jak je to s operatormi, este raz:	
	- pozor na referenciu operatorov ako slov, ako napr. `plus` 
	
	- klasicke operatory:
	[] +-+ (x:xs) = (x:xs)
	(y:ys) +-+ (x:xs) = y : (ys +-+ (x:xs))
	infixr 6 +-+
	
	- slovne operatory (podlieha patternu na VARID):
	[] `uber` (x:xs) = (x:xs)
	(y:ys) `uber` (x:xs) = y : (ys `uber` (x:xs))
	infixr 7 `uber`
	
	- funguje potom toto:
	(`uber`) [1, 2] [3, 4, 5]
	(uber) [1, 2] [3, 4, 5]
	uber [1, 2] [3, 4, 5]
	[1, 2] uber [3, 4, 5]
	(zvysne varianty nefunguju)
		
	- aj toto funguje:
	parada x y = x + y
	infixr 9 `parada`
		
	- a aj toto funguje:
	(***) a b = a * b
	infixr 9 ***
	
	- vzhladom na to, ze je to pracne toto predpripavit v MPS, nebudeme sa venovat slovnym operatorom, ako je napr. `op`
	- nicmenej by asi stalo za to dokoncit definiciu ako je napr. (***) a b = a * b
	
- Referencovanie v typoch:
	- TypeReference: musi referencovat nazov datatypu 
	- (NodeCONID nemozeme mat pre vsetky ucely, lebo tam, kde sa referencuje datatyp, nemozno referencovat tiez aj konstruktor)
	
	- Vid priklady:
	ff :: (Eq a, Num i) => a -> [i] -> Bool
	ff :: (Eq k) => k -> [(k,v)] -> Maybe v
	type Data = String
	type Breadcrumbs a = [Crumb a]	
	- potom su tu este implicitne typy, ako Bool, Int, String, ...
	- vsetky typy zacinaju velkym pismenom
	- cize opat je nutne postavit obalku nad menami typov (TypeName, TypeReference), ktore su v tomto spolocne
	
- Nejednoznacnost pri aplikacii konstruktorov:
	data Maybe a = Just Tree a a a
	- ku ktoremu konceptu sa viazu jednotlive "a"?
		a) data Maybe a = Just (Tree) a a a
		b) data Maybe a = Just (Tree a) a a
		c) data Maybe a = Just (Tree a a) a
		d) data Maybe a = Just (Tree a a a)
		
	- proste to natvrdo obalim do zatvorky a nebudem riesit 
	- inak by to samozrejme chcelo riesenie na urovni transformacii, co je otrava
	- tak som vynechal zatvorky a tuto ambiguitu poriesil takto:
	TypeReference:
	group 
	  variables 
		<< ... >> 
	  condition (editorContext, node, model)->boolean { 
		// Transformation menu for adding additional arguments inside TypeData 
		// Must not be ambiguous => if we are already inside a TypeData / DataConstructor, then this does not apply 
		// Example: "data LinkedList a = Nil | Node Maybe a" - is it "Node (Maybe a)" or "Node (Maybe) (a)"? 
		if (TreeUtilities.testKindsUpward(node.parent, new arraylist<concept<>>{concept/TypeData/})) { 
		  node<> sp = node.parent.parent; 
		  if (!sp.isInstanceOf(TypeData) && !sp.isInstanceOf(DataConstructor)) { return true; } 
		} 
		 
		return false; 
	  } 
	  include named menu TypeReference_AddSimpletypeForTypeData for current node
	  
	Simpletype:
	group 
	  variables 
		<< ... >> 
	  condition (editorContext, node, model)->boolean { 
		// Transformation menu for adding additional arguments inside TypeData 
		// Must not be ambiguous => if we are already inside a TypeData / DataConstructor, then this does not apply 
		// Example: "data LinkedList a = Nil | Node Maybe a" - is it "Node (Maybe a)" or "Node (Maybe) (a)"? 
		if (TreeUtilities.testKindsUpward(node.parent, new arraylist<concept<>>{concept/TypeData/})) { 
		  node<> sp = node.parent.parent; 
		  if (!sp.isInstanceOf(TypeData) && !sp.isInstanceOf(DataConstructor)) { return true; } 
		} 
		 
		return false; 
	  } 
	  include named menu Simpletype_AddSimpletypeForTypeData for current node
	  
- Treba poriesit udavanie triedy v pripade anotacii, ako napr. ff :: (Eq a) => a -> a -> Int
	- az na to, ze triedy sme kompletne vynechali, takze sa tym asi nebudeme zaoberat
	
- Export typov a konstruktorov:
	- trochu krkolomnejsie, ale poriesene podobnym sposobom, ako zvysok pre export modulov
	- je mozne pridat zatvorku pre specifikovanie konstruktorov iba pokial ide o typ "Data" (t.j. pre type String = [Char] nedovoli specifikovat 
	konstruktory)
	- pripomenme si, jak to ma oficialne podla "gramatiky" vyzerat (rovnako pre module tak pre import):
	
	import learnyou.chapter14.TakingAWalk (Tree, Direction, freeTree, **, !!, Lexeme(..)) 
	- Lexeme je datatyp a importujeme aj vsetky jeho konstruktory
	
	data Tree = Leaf | Branch | Other
	Tree(Leaf, Branch)  	-- konkretny export vymenovanych konstruktorov
	Tree(..)				-- export vsetkych konstruktorov pre Tree
	Tree					-- export len datatypu Tree bez jeho konstruktorov (praca s tymto je mozna potom len abstraktne pomocou funkcii, 
							   ale nemozno zostavit vlastny Tree)
							   
- Import typov a konstruktorov:
	- co znamena, ze mam import mymodule.Exemplar hiding (BinaryTree(Nil)) ?
	- importujem vsetky konstruktory okrem Nil, alebo neimportujem vobec cely datatyp BinaryTree? co sa ma diat?
	- takto (pravdepodobne):
	import Text.Read (BinaryTree) - importuje len BinaryTree a nic ine
	import Text.Read (BinaryTree(..)) - importuje len BinaryTree so vsetkymi jeho konstruktormi
	import Text.Read (Nil) - importuje len konstruktor Nil a nic ine
	import mymodule.Exemplar hiding (BinaryTree(Nil)) - skryje jak BinaryTree, tak Nil
	import mymodule.Exemplar hiding (Nil) - skryje len konstruktor Nil
	
- List comprehension:
	[ [ x, y, z ] | x <- [ 1, 2 ], y <- [ 3, 4 ], z <- [ 5, 6 ] ]
	[ (c, z) | c <- str, isIn c ['A'..'Z'], let z = min a b]
	- nakoniec som sa vybral tou jednoduchsou cestou
	- nicmenej, keby sme to chceli poriadne spravit, tak takto:
		- pri napisani "let" transformuj abstraktny kvalifikator na let
		- inak je tazke rozlisit medzi tym, ci ide o pattern, alebo expression	
			- guard je totiz cisty expression, napr.: isIn c ['A'..'Z']
			- assignment je zase pattern <- expression, napr.: (a,b) <- [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]
			
			- v pripade analyzy gramatiky s look-ahead je to jednoduche rozlisit (staci podla pritomnoti "<-")
			- pri postupnom budovani zlava je to vyrazne horsie
			
			(a,b) <- [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]
			x <- if 1 < 2 then [1..5] else [6..7]
			
			isIn c ['A'..'Z']
			1 > 9
			- pri pisani 1 este nevieme, ci ide o pattern, alebo o expression, to vieme az v momente pouzitia operatoru
			- museli by sa asi rozobrat vsetky moznosti a postupovat stylom "incomplete-command"
				- cize vsetko by bolo klasicky pattern, co by sa transformovalo na expression, pokial by muselo
				- v pripade "isIn" by sam uzivatel urcil, ze ide o referenciu na "isIn" (cez ctrl+space) a to by to transformovalo na guard variant
					- pripadne pokial by sa zhodlo s akoukolvek referenciou, transformovalo by sa samo
					- tu je inak velky problem, pretoze nevieme spatne zaregovat na zmeny, MPS umoznuje len tie transformacie sprava, cize je to skoro
						nemozna uloha
				- pritomnost lubovolneho operatoru transformuje na guard variant, okrem "<-"
				
	- inak, priklady:
	[x | y <- [1..5], x <- [1..7]]
		- vrati [1,2,3,4,5,6,7,1,2,3,4,5,6,7,1,2,3,4,5,6,7,1,2,3,4,5,6,7,1,2,3,4,5,6,7]
		- cize [1..7] opakovane 5x
		- y sa totiz nevyskytuje nalavo, ale politika frege je aj tak, ze vyhodnoti priradenie1 * priradenie2 * ... * priradenien
		
	[x | (y,z,w) <- [(1,2,3),(1,2,4)], x <- [1..7]]
		- vrati: [1,2,3,4,5,6,7,1,2,3,4,5,6,7]
		
- Rozhodol som sa prefixovat properties, ktore nie su viditelne, ale maju zvlastne chovanie, podrzitkom "_"
	- napr. _hidden property pre import
	
- Indentacia
	- Jak to funguje a co je povolene?
	- All grouped expressions must be exactly aligned 
	- Indent layout nad beznym expression
		ff x = x + x + 3
		 + 1 + x

		- If, cez rozhodnutie na zaklade nejakej skrytej premennej
		if foo then first thing else something_else
		if foo
		 then first thing
		 else something_else

			- funguje inak aj toto, pokial prave nie sme v monadach:
			if foo
			then first thing
			else something_else

			- a toto tiez, co som si odskusal:
			ff x = if x > 0
			 then "hello"
			 else "olleh"

			- btw, toto mi robi a rozhodol som sa tuto chybu ignorovat (otravne a tazke to spravit spravne):
				usingIf = "Hello, world" ++ if 0 < 1                       ++ "else?"
											 then "0" ++ "something else"
											 else "1" ++ "something else"

				- overit, ze sa strom pri if a podobnych konceptoch trvori spravne
					- napr. g = if 1 > 0 then 1 else 0 + 1, tak 0 + 1 spada pod else vetvu a nie je to tak, ze by + 1 tvorilo samostnatny TopExpression
					- vsetky TopExpression, ktore nie su PrimaryExpression, "koncia" vzdy na Expression, t.j. maju vetvu, podobne ako if, prip. case a pod.
					- s tym neviem, co presne zatial urobit a jak tomu zabranit...

		- Guards
		myFunction x1 x2
		  | x1 > x2 = addOne x1
		  | x1 < x2 = addOne x2
		  | otherwise = x1
		    where addOne = (1+)

		- Where
		where
		  x = a
		  y = b

			- funguje aj toto:
			where 	x = a
					y = b

			- BTW, nested where je uplne v poriadku:
			main = interact wordCount
			  where
				wordCount input = show (ls ++ " " ++ ws ++ " " ++ cs  ++ "\n")
				  where
					ls = lines input
					ws = length words input
					cs = length input	
					
		- Let, plati rovnako, ako pre where:
		let
		  x = a
		  y = b
		 
		let x = a
			y = b
			
		foo x =
			let s = sin x
			    c = cos x
			in 2 * s * c
					
		- Case
		case x of
		 p  -> foo
		 p' -> baz
		 
		- Data
		data GreekAlphabet = Alpha | Beta
		  | Gamma
		  
- Anotacia funkcii
	usingIf, (*), (++), (+) :: Int-> Int
	- aby som zachoval tu plynulost editovania, tak je mozne napr. napisat "usingIfX ::" (s preklepom "X") a anotaciu vytvori, ale nenajde spravnu
	referenciu (proste sa pouzije metoda findAndSetReference)
	- ak by uzivatel chcel referencovat cez ctrl + space, tak musi najprv napisat :: (vytvori anotacny koncept) a potom moze klasicky referencovat
		- zial, nejde v MPS reagovat na pouzitie ctrl + space a podla toho nastavit transformaciu na anotaciu
		- nevieme teda na zaklade tohto rozlisit medzi anotaciou a function-definition
	- zaroven funguje to, ze ked napisem "+," tak vytvori "(+),"
		- ale to len, kde je nejednoznacnost, lebo napr. po napisani "++" uz okamzite vie, ze nic dalsie nebude, takze transformuje na (++) a ciarku 
		by sme nechtiac napisali do zatvorky
		
- Nefungovalo spravne pridavanie definicii funkcii ss argumentami do where
	- ...ale iba, pokial uz okolita funkcia bola tiez taka, ze mala nejake argumenty
	- preto, lebo pri transformacii FDAssignment do FDGrouped sa kontroluje, ci nie sme nahodou len nejaky dalsi matcher, t.j. obaleny v nejakej
	FDGrouped
	- lenze pokial sme vo wherem, kde tiez mozu byt vnorene FDGrouped, tak sa toto kontrolovat musi opatrne - plati len do prveho najdeneho where
	
- Where scoping
	- normalne nic komplikovane, proste where musi navonok poskytovat svoj scope
	- problem je, ze where obsahuje niekolko vlastnych function-definition
		- ich prava strana napr. chce ziskat meno funkcie
		- problem je, ze nemoze:
			- funkcia poskytuje svoje meno v ramci public scopeu
			- kedze ide o public, deleguje na rodica s tym, ze neskor rodic zahrnie jej public scope
			- lenze rodic nezahrnie - pretoze where neposkytuje navonok scope (je naschval skryty), tak uz sa nikdy nezahrnie
			- riesenim je nutene pridat public scope deti, pokial pochadza volanie od deti:
			
			public Scope getScope(concept<> kind, node<> child) 
			  overrides ScopeProvider.getScope { 
			  // Request for scope comes from a child 
			  CompositeScope cs = new CompositeScope(); 
			  cs.addScope(parent scope); 
			   
			  // We need to include the current let definitions' public scopes as well 
			  // Otherwise they will not be included, since scope of "where" is hidden from the public 
			  cs.addScope(this.letDefs.getPublicScope(kind, child, this, "public")); 
			   
			  // Return 
			  return cs; 
			}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

	- malo by to fungovat takto:
	myFunction2 l1 = "s" + l1 + l2_1 + l2_2                                                           
	   where                                                                                          
		  l2_1 l2_1_a1 = "s" + l2_1 + l2_1_a1 + l1 + l2_2 + l3_21_1 + l3_21_2                         
			 where                                                                                    
				l3_21_1 l3_21_1_a1 = "s" + l3_21_1 + l3_21_1_a1 + l1 + l2_1 + l2_1_a1 + l2_2 + l3_21_2
				l3_21_2 l3_21_2_a1 = "s" + l3_21_2 + l3_21_2_a1 + l1 + l2_1 + l2_1_a1 + l2_2 + l3_21_1
		  l2_2 l2_2_a1 = "s" + l2_2 + l2_2_a1 + l1 + l2_1 + l3_22_1 + l3_22_2                         
			 where                                                                                    
				l3_22_1 l3_22_1_a1 = "s" + l3_22_1 + l3_22_1_a1 + l1 + l2_2 + l2_2_a1 + l2_1 + l3_22_2
				l3_22_2 l3_22_2_a1 = "s" + l3_22_2 + l3_22_2_a1 + l1 + l2_2 + l2_2_a1 + l2_1 + l3_22_1