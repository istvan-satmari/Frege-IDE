- zacat function definition
	- najprv jednoduchsie veci, typu "if" a pod.
	- bude treba nejakym sposobom poriesit binary expression a zatial vobec nemam predstavu
		- problem je samozrejme v tom, ze to, jak je ten strom budovany, zalezi (priorita operatorov)
		- to budem potrebovat pri typovom systeme
		- hlavne to, ze priorita jednotlivych operatorov sa da menit cez fixity a ja neviem, co s tym...





Asi by som mal zlepsit najprv ten editor uz v pripade existujucich konceptov? (t.j. pouzit ten default editor?)
	- momentalne upravujem typovanie a su tieto issues:
		- za napisanim typovej premennej nejde nic pridat (problem toho, ze je textova)
		- pokial som v tuple, nejde zmazat TypeFunction, konci to na "<no returnType>" (ako argument tuplu)
	- potom sa vrhnut este na typeEditor




Skoncil som pri definicia funkcie vseobecne TODO
	- preskumane, ci pattern sedi podla gramatiky, cize sa rovno mozno vrhnut na ackie transformacie
	- otazka: urobit ten specialny sposob zapisovania so skryvanim siveho stvorcu? 
		- urcite hej, pokial nepojdu klasicke transformacie





Zoradit dokument (jednotlive issues) podla priority
	- a brat ich v tejto priorite



Dokoncit veci oznacene TODO:
- definicia funkcie vseobecne TODO
- topex TODO
(potom to zhruba prejst)





O com sa je nutne vyjadrit
--------------------------
- na to, aby sa pridal context, je nutne napisat '=>' nalavo (toto treba oznamit v uzivatelskej dokumentacii)
	- Tymto sa urcite nebudem zaoberat (nici mi to gramatiku):
	onLeft str = (++ str)
		-- pozor, tu "++" nie je aplikacia funkcie, ale operator
		-- jak to spravit?
	onRight str = (str ++)
	onRight str = (++ str)
	onRighta str = (++ str ++ "a")
		-- dalsi otaznik, neviem, jak na tieto
		
	f x = (x+)
	g y = (f 1) y		- (f 1) vrati funkciu, ktoru ihned aplikujeme na "y"
	
	f x = (-x)
	g y = y (f 1)		- prelozi, ale spusta sa napr. cez "g (7 +)" (t.j. y je funkcia prijimajuca 1 celociselny argument)
		
	f x = (-x)
	g y = y + (f 1)		- ok, (f 1) vrati cislo

	f x = (x+1+)		- neprejde
	g y = (f 1) y
	
	f x = ((x+1)+)		- prelozi
	g y = (f 1) y
	
	f x = (++x)
	g y = (f "hello") y	- prejde pre 'g "str"'



konceptualne nedostatky, t.j. na co sa zabudlo
----------------------------------------------
infixl 7 `-:`
infixr 8 `plus1`
- pozor, potom sa v programe pouzivaju inak (ten slovny je nutne ohranicit apostrofmi, operatory sa pouzivaju priamo)
f = 1 -: 7
f = 1 `plus1` 7



vseobecne postrehy
------------------
- niekedy by to chcelo preveditelnost, napr.:
	- uzivatel zada "class"
	- zrazu si to rozmyslel a chce to zmenit na "instance" (a zachovat zadane data)
	- alebo lepsi priklad:
	- mame anotaciu funkcie, napr.: f :: String -> Maybe Int
	- chceme rychlo transformovat na: f :: [String] -> Maybe Int
	- toto nebudeme riesit, maximalne vytvorime nejaky 1 priklad a zmienime sa o tom v diplomke
		- zmienit sa stylom "pre module koncept sme to urobili takto a potom pre ostatne by sa to vyriesilo takto a takto"
		- uzivatel musi pisat kod postupne a spravne
		
- nedokoncene konceptualne casti
	- pozriet sa na operatory; v Haskelli existuje len 1 unarny operator, a to minus (treba opravit)
		- jak sa potom chova vykricnik? (negacia)
		
- odstranenie casti
	- napr. import MyModule as MyModuleAssociation
	- chceme vymazat "as" a zachovat povodne
	- takuto uzivatlesku privetivost uz ale vacsinou chceme zachovat
	- cize je nutne rozumne nastavit editor pre jednotlive koncepty
	- napr. "as" sa musi objavit len ked "MyModuleAssociation", ako child node, je zadany
	
- vyplnit "description" a "alias" pre koncepty pre jasnejsiu napovedu pri "ctrl + space"
	
- textgen

- par demonstracnych kniznic, ako ukazka, ze nam funguje import
	


referencovanie
--------------
- definovana trieda
- definovana instancia
- definovany datatyp
- definovane konstruktory nejakeho datatypu

- importovane moduly
	- otazka, ci v takom pripade sa pouziva meno, co sa dosadzuje za "as", alebo klasicke
	- napr.: import MyModule1 as MyModuleName

- definovana funkcia
	- pozor na patterns

- definovane polozky v inom module 
	- vid language patterns pre toto
	- nodes spadajuce pod tu istu zlozku (t.j. modely v ramci tej istej zlozky) na seba vidia beznym sposobom, ako by slo o 1 model

- import s "as"
import learnyou.chapter07.geometry.Sphere as Sph ()
	- zmeni sa odkazovanie v ramci samotneho programu: uz nebudeme pouzivat Sphere.doSomething ale Sph.doSomething
	
	

module
------
- odkazovanie na existujuce polozky
module MyModule (MyType, MyClass, myFunc1) where
	- MyType, MyClass, myFunc1 su existujuce nadefinovane polozky v programe

- odkazovanie na uz nadefinovane moduly
module MyBigModule (module Data.Set, module Data.Char) where
	import Data.Set
	import Data.Char
	- Data.Set, Data.Char su uz naimportovane moduly a reexportuju sa
	- vyriesene zhruba je, ide len o to, ze co s "as" klauzulou, pokial sa vyskytne v import-e
	- zaroven napoveda pri ctrl+space rozhodne nie je dobra
	- treba zaroven 

- exportovanie existujuceho datatypu
data Tree a = Leaf a | Branch (Tree a) (Tree a) | SuperBranch
module MyModule (Tree(..)) where
	- exportuje vsetko
module MyModule (Tree(Branch, SuperBranch)) where
	- exportuje len Branch a SuperBranch konstruktory v ramci datatypu Tree



import
------
- zaklad
import frege.prelude.Math
	- obmedzit scope tak, aby sa nedal importovat sucasne nadefinovany modul

- odkazovanie na existujuce polozky v ramci daneho importu
import learnyou.chapter14.TakingAWalk (Tree, Direction, freeTree, **, !!)
	- Tree, Direction, freeTree, **, !! su polozky v ramci modulu "learnyou.chapter14.TakingAWalk"
	- pozor na to, ze operatory su tiez polozky v ramci daneho modulu

- odkazovanie na existujuce polozky, ktore sa daju nasledne viac specifikovat (import tried)
import Text.Read (Read) -- import triedy
import Text.Read (Read()) -- import triedy, avsak nie jej funkcii
import Text.Read (Read(readsPrec, readList)) -- import triedy s konkretnymi funkciami
import Data.Char hiding (isControl, isMark) -- import funkcii
	- readsPrec, readList su polozky v ramci danej triedy

- odkazovanie na existujuce polozky, ktore sa daju nasledne viac specifikovat (import datatypov)
import Text.Read (Lexeme(...))
	-- "data" typu "Lexeme" so vsetkymi jeho konstruktormi

- importovane polozky ovplyvnuju referencovatelne polozky
	- ovplyvnuju aj ich "namespace", t.j. klasicke "f" moze byt pouzivane cez "mypackage.f"

	

typovanie
---------
- zaklad vychadza z upravenej gramatiky:
rho ::= context? typeFunction			-- pozor, premenovane: rho na FullType
context ::= '(' contextPart (, contextPart)* ')'  '=>'
contextPart ::= CONID VARID
typeFunction ::= simpletype ('->' simpletype)*
simpletype ::= 	'(' typeFunction ')'
				QCONID simpletype* 		-- reprezentuje "data", vstavane typy a typove synonyma
				'[' typeFunction ']'
				'(' typeFunction (, typeFunction)+ ')'
				VARID					-- reprezentuje typovu premennu, napr. "a", cize mozno pisat cokolvek
				
- tranformacie na urovni simpletype (pokial je abstraktneho typu):
	- referencovanim akehokolvek datatypu ci bezneho typu (napr. Int, Bool) ci typoveho synonyma (type) sa prevedie na typeData a mal by sa vytvorit spravny pocet pozadovanych argumentov automaticky

- transformacie na urovni context:
	- CONID referencuje nejaku triedu
	- VARID je typova premenna a mozno tam napisat cokolvek

- editor
	- v tejto chvili robi vzdy medzeru; mozno vylepsit? (cez Cell KeyMap)
	
- mozne vylepsenie:
	- VARID z context je mozno referencovat, t.j. by sa pridal este jeden potomok ku simpletype, ktory referencuje typovu premennu z context-u
	- takuto referenciu by sa hodilo cez check omarkovat a vyhlasit warning, pokial nebola pouzita
	
- priklady pre spatnu referenciu:
	[a] -> [b] -> [(a, b)] -> [[a]]
	a -> (a -> b) -> b
	(Monoid m) => (a, m) -> (a -> (b, m)) -> (b, m)
	(Real a) => [(a, a)] -> Maybe a
	(Eq a, Num i, Integral b) => a -> [i] -> Int -> Bool -> String
	a -> [Crumb b] -> [Direction] -> ([a], [a]) -> (a, b, c)
	
	

podporovane vstavane triedy a typy
----------------------------------
- triedy (nachadzaju sa v context-e)
Num 		-- superclass to Int, Integer, Float, Double	(i.e. this is a type-class, while Integer, Int, ... are simply types)
Integral 	-- superclass to Int, Integer
Floating 	-- superclass to Float, Double
RealFloat
	- vsetky ostatne, aj Eq, Ord, ..., si musia uzivatelia nadefinovat sami
	- nicmenej tieto zakladne triedy mozno naimplementovat len ako priklady

- typy (types, datatypes, ...)
Char  
Bool  	-- True / False
String
Integer	-- BigInteger v podstate
Float
Double
Int		-- 32-64 bits


	
type
----
- upozornenie, ze typova premenna nebola nikde pouzita
type Breadcrumbs a = String

- odkazovat sa na typove premenne vytvorene nalavo
type Breadcrumbs a = [Crumb a]

- nie je mozne pouzit vlastnu typovu premennu, ktora nebola vytvorena nalavo
type Breadcrumbs = (a, a)
	- tento priklad pochopitelne vyhodi chybu pri kompilacii
	
- mozne vylepsenie
	- jednotlive typove premenne nalavo by mali byt navzajom odlisne, napr. type JAM a a = [a] (ale nie je to chyba, cize takato kontrola nie je nutna)

	
	
data
----
- zaklad
data Maybe a = Nothing | Just a
	- napravo mozu byt pouzite len typove premenne definovane nalavo
		- asi by som nadefinoval referencny koncept dediaci od Simpletype, ktory ale moze byt pouzity iba tu, v klasickom typing nemoze
	- kontrola, ze "Maybe", "Nothing", ani "Just" este neboli nikde definovane ("Maybe" v ramci ziadneho data, "Nothing" a "Just" v ramci ziadneho ineho konstruktoru)

- aj ine, nez typove premenne
data Point = Point Float Float | Circle Point Float | Rectangle Point Point	| Folder [String]
	- okrem typovych premennych mozno odkazovat aj na ine polozky, tu sa treba riadit "typovanim"
		- minimalne ine "data" (aj rekurzivne) a potom typy, ako Float, Integer a i.
			- datatypes, types, vstavane typy (Float, Integer, ...)
		- pozor, jednotlive data referencuju tie uz nadefinovane
	- celkovo napravo nie je typova premenna, ale tzv. simpletype, cize referencovanie veci vychadza od neho

- upozornenie na nepouzite typove premenne
data Opx a b c = Sumx a | Zerox
	- nejde ale o chybu, iba o vystrahu



definicia funkcie vseobecne TODO
---------------------------
- vzhladom na to, ze tato cast ma informativny charakter, su ulohy (len a len tu) oznacene "TODO"

- gramatika pattern-ov funkcii
	- je nieco, o com by sa hodilo zmienit, kedze nejde o oficialnu gramatiku a odvodzovala sa tazsie

pattern ::= VARID arg*  				-- napr.  f x y = 2*x
			arg 						-- napr.  [1, gg] = [1, 7]
			arg OPERATOR arg			-- napr.  a `myop` b = a + b

arg ::=	pVariable						pVariable ::= VARID	| _
		pLiteral						pLiteral ::= BoolValue | IntValue | DoubleValue | CharValue | StringValue
		pConstructor					pConstructor ::= '(' CONID arg* ')'
		pTuple							pTuple ::= '(' arg (',' arg)* ')'
		pList

pList ::= 	'(' arg (':' arg)* ':' pList ')' 	-- variant (x : xs)
			'[' ']'								-- prazdny zoznam
			'[' arg (',' arg)* ']' 				-- udanie jednotlivych argumentov
			pVariable							-- sluzi ako zakoncovac prveho variantu, kde mame (x : xs)

Pripomenme, ze jednotlive polozky zoznamu musia byt rovnakeho typu:
	- prejde: f [1, 2, 3] = 1
	- neprejde: g [1, false, true] = 1
	- prva polozka urci typ, ostatne musia byt rovnakeho typu
	- typ je vsak tazke urcit bez typesystem, cize to ponechavame tam
	
- akcie transformacie na urovni pattern:
	- predpokladajme najprv, ze mame jednoduchy arg, potom ked dopiseme napravo od neho medzeru a pridame symbol pre nejaky operator, vieme, ze ide o tento variant:
		- arg OPERATOR arg
		- napr. a `myop` b = a + b
	- cize problem je prvy variant typu "VARID arg*", pretoze samostatny arg tiez moze byt VARID, pokial ide o pVariable
		- nicmenej po zadani medzery napravo mozno pridat novy arg a previest transformaciu, pokial ten prvy bol skutocne typu pVariable
	- celkovo tak:
		- mame default samostatny arg
		- pokial je jediny a po pridani medzery napravo a zacati pisania symbolu, ktory vyhovuje operator-u, transformujeme na variant 3
		- pokial je jediny a po pridani medzery napravo a zacati pisania symbolu, ktory nevyhovuje operator-u a zaroven je objekt nalavo VARID (pVariable), transformujeme na variant 1
			- operator sa moze skladat iba z tychto symbolov: #  $  %  &  *  +  .  /  <  =  >  ?  @  \  ^  |  -  ~ :
			- pozor na to, ze operator moze byt aj slovo, potom prijimame aj symbol `, napr. `myop`
			- jediny konflikt je tu pri ':', ktory sa ale aj tak moze vyskytnut len v ramci pList, cize nepredstavuje problem
		- pokial uz sme v ramci variantu 1, pridanie medzery pridava neinicializovany arg
		- pokial uz sme v ramci variantu 3, ziadne dalsie transformacie nie su potrebne
		zatial to velmi spolahlivo nefunguje, cize treba nejako vyriesit
	- vzhladom na obmedzenejsie moznosti MPS (tyka sa predovsetkym toho, co mozno napisat do polozky text v ramci transformacie), treba rozumne naplanovat
		arg
		arg (musi byt PVarName) arg (PatternArgument) (mozno pridavat dalsie argumenty)			-- variant 1
		arg (moze byt cokolvek) op (operator) arg (ziadne dalsie polozky uz pridavat nemozno)	-- variant 2
		- chceme, aby ak ide o variant 1, tak pridanim napr. '[' sa okamzite aj pridal argument typu PBracketList
		- skutocne, jediny problem, ktory tu s MPS mam je, ze tato cast:
		  text (editorContext, node, model, pattern)->string { 
			":"; 
		  } 
		- ...nevracia list stringov ale iba jeden string, co je strasne odveci
			- mozem sice vratit "pattern" a checknut to v "can execute", ale to budem mat konflikty v transformacnom menu (zobrazi viacej poloziek naraz, co nechcem - chcem, aby transformacia bola okamzita)
		- jake tu inak mame moznosti?
			- moj sposob, ze nadefinujem pre kazdy symbol operatoru tu istu akciu (cize poriadne porusenie zasad DRY, cize som sa pokusil aspon delegovat samotny akt transformacie do osobitnej funkcie)
			- vytvorit specialne nodes:
				"arg" 					-- napisanim "" (cize cokolvek) transformacia na nasledujuci:
				"arg" "arg or op"		-- nad "arg or op" je postavena wrapper substitucia, cize jednoduche
										-- kedze tu ale pri pouziti "op" rozhoduje substitucia, uz nie je mozne transformovat, cize "op" musi byt uzol o dvoch child
										-- pokial ale bude pouzity "op", tak neprejdu dalsie transformacie na pridavanie dalsich argumentov
										-- takto by to slo urobit, ale uz sa mi s tym nechce zatazovat, takze necham povodny sposob

Mozeme spomenut do diplomky implementovanie tohto: ziadna premenna sa nesmie vyskytovat v danom patterne viackrat bez ohladu na postavenie	
	- priklad: f x x = 3 * x
	- priklad: f x (x:xs) = 3 * x
	- je to okontrolovane tak, ze je do kazdeho subkonceptu Patternu naimplementovana metoda GetVariableNames
	- proste to prejde stromcek rekurzivne a vyzbiera zhody
	- aj toto bolo podobne vyriesene:
	- pokial lava strana neobsahuje ani jednu premennu ani VARID ako nazov funkcie, mal by vyhlasit chybu
		- priklad: [7] = [7] 
		- dany priklad neprejde skompilovat	
										
						
TODO: pozor, ze pri definovani PatternOperator moze byt operator aj slovo, napr. `myplus`										
			
TODO: akcie transformacie
	- referencovanim akehokolvek konstruktoru pridame pConstructor
			- hodilo by sa pridat aj zodpovedajuci pocet argumentov
			- hodilo by sa zmienit, ze zatvorkou '(' zacina aj pConstructor, nicmenej museli by sme vytvarat vela akcii, tak len do dokumentacie uvedieme, ze to je takto a ze sa to da lahko rozsirit na podporovanie aj tohto variantu			
	- pripomenme, ze toto nie je vsetko, lebo budeme musiet vyhadzat z abstraktneho definition, ktory ale konfliktuje s annotation
		- co teda budeme musiet urobit je zlucit tie transformacie, ktore maju zhodne, do nejakeho "incomplete-command", z ktoreho sa potom bude vychadzat
		- o tomto sa hodi zmienit v ramci diplomovky
	- referencii je tu pomenej, potrebna je hlavne pre konstruktor nejakeho datatypu
		- jednotlive mena funkcii nereferencujeme, ani pokial bola zadefinovana anotacia nejakej funkcie, ktoru prave definujeme, neriesime to
				
Mozno TODO: detegovat, ci 2 pattern-y su zhodne	
	- napr. tieto pattern-y su zhodne:
	f a [b, c] = 1
	f i [j, k] = 2
	- staci len prejst cely strom a zistit, ci su koncepty rovnakych typov
	- t.j. nezalezi na tom, ze v dovch pattern-och su pVariable, ktore maju roznu hodnotu (napr. "a" a "i"), ale to, ze su obaja pVariable, tak na tom zalezi
	- t.j. pokial sa cely strom zhoduje, vyhlasit chybu
	- toto sa trochu odlisuje od predosleho bodu tym, ze strom nesmie byt uplne rovnaky - musia byt len rovnakeho typu
		[] :-: [] = []
		[x, xs] :-: [y, ys] = [x * y, xs * ys]
		- su rovnakeho typu, ale nemaju rovnaky strom, pretoze ten druhy obsahuje iny pocet argumentov v pList, nez ten prvy	
	
	

TODO: cez typesystem zistit, ci v zadanom pattern-e ma zoznam (list, t.j. [a, b, c]) polozky rovnakeho typu
	- podtrzitko _ vzdy vyhovuje akemukolvek typu
	- premenna vzdy vyhovuje akemukolvek typu
	
TODO: cez typesystem zistit, ci v zadanom pConstructor-e su argumenty spravneho typu
	- datatyp definuje, akych typov prijima jednotlive polozky
	- typicky lubovolneho typu, napr. data Maybe a = Just a | Nothing
	- nicmenej niekedy striktneho, napr. data Point = Point Int Int

TODO: detegovat redefinition
	- redefinition sa povazuje za chybu
	- napr. tu ide o redefinition:
	(a : b : c : _) = [1, 2, 3, 4, 5, 6, 7]
	a = 10
	- aj tu ide o redefinition:
	a (1, 2) = 1
	a [1] = 0
	- priklad pre variant 3, kde sa definuje operator:
	[] :-: [] = []
	(x:xs) :-: (y:ys) = (x * y) : (xs :-: ys)
	- je v poriadku
	[] :-: [] = []
	(x, xs) :-: (y, ys) = (x * y)
	- v poriadku nie je
	- inymi slovami pokial su patterny rovnakeho typu, tak ide len o novy pattern, pokial ale maju rozlicny typ, tak je to chyba
		- v tomto priklade su patterny rovnakeho typu, t.j. vzdy ide o zoznamy
		[] :-: [] = []
		(x:xs) :-: (y:ys) = (x * y) : (xs :-: ys)
		- v tomto priklade su patterny rozneho typu, t.j. raz ide o zoznamy a potom ide o tuple
		[] :-: [] = []
		(x, xs) :-: (y, ys) = (x * y)
	- pre variant 1 rovnako, len pojde o zhodne nazvy funkcii
	- zostava teda specialny pripad variantu 2 s moznostou kombinacie s variantom 1:
	(a : b : c : _) = [1, 2, 3, 4, 5, 6, 7]
	(a : b : c : _) = [2, 3, 4, 5, 6, 7] 		-- je redefinition prveho
	a = 10										-- je redefinition prveho
	- tymto sa (mozno) nebudeme zaoberat (v takom pripade sa o tom treba zmienit v diplomovke)
	- nicmenej si ujasnime, jak by to prebiehalo:
		- pokial pouzijeme variant 2, tak prehlasit, ze je to to iste, ako variant 1, s vynimkou, ze taketo nieco nie je mozne zadefinovat: (f x, g y, h z) = (2 * x, 3 * y, 4 * z)
		- pripady:
		(Just a) = (Just 1)
		(a : b : c : _) = [1, 2, 3, 4, 5, 6, 7]
		[0, a] = [0, 1]
		(0, a) = (0, 1)
		- cize pokial mame variant 2, tak vyzbierame vsetky dostupne pVariable
		- potom porovname oproti ostatnym variantom 2, ktore pouzivaju nejaky z predosle nadefinovanych pVariable - pokial pouzivaju, je to chyba (redefinition)
		- analogicky porovname oproti variantom 1, ci nejaka funkcia neobsahuje rovnaky nazov
		- algoritmus je jednoduche zistovanie, ci 2 mnoziny maju nejaky prienik
	- tento bod mozno rozsirit o detekciu nasledujuceho:
		- medzi definiciami tej istej funkcie mozu byt prazdne riadky, ale nemoze byt medzi nimi definovana ina funkcia, napr. toto je zle:	
		mDouble 0 = 1
		mSum x = x + 1
		mDouble x = x * 2
		


zip (x : xs) (y : ys) = (x, y) : zip xs ys
x -: f = f x

infixl 8 `plus1`
2 `plus1` 3 -- pouzitie
a `myop` b = a + b
f n = n `div` 2

- vstavane operatory a typova kontrola:
equals x y = (x == y) && !(x != y)
sum a b = a + b
reverse (x : xs) = reverse xs ++ [x]
repeat x = x : repeat x
1 : [ 2, 3, 4, 5 ]
(toList "Steve Buscemi") !! 6

-- Operator mozno pouzit ako funkciu ked sa uzatvorkuje
succ a = (+) 1 a
(Rational x1 y1) +. (Rational x2 y2) = (x1 * y2 + x2 * y1) % (y1 * y2)
listOfFuns = map (*) [0..]

- hnusny currying
myresult = filter (== 3) [ 1, 2, 3, 4, 5 ]
mylist = map (^ 2) [1..]
add10 = (10 +)
onLeft str = (++ str)
onRight str = (str ++)

multThree x y z = x * y * z
multTwoWithNine = multThree 9
multWithEighteen = multTwoWithNine 2
mymax = (max 4) 5
succ a = (+) 1 a

surface :: Shape -> Float	
surface (Circle _ r) = Math.pi * r ^ 2
surface (Rectangle (Point x1 y1) (Point x2 y2)) = 
    (abs $ x2 - x1) * (abs $ y2 - y1)

replicate n x
    | n <= 0    = []
    | otherwise = x : replicate' (n - 1) x
	
-- Mozno pouzit aj jedineho a potom dalsi pripad vyriesit pomocou pattern-matchingu
take n _
    | n <= 0   = []
take _ []     = []
take n (x : xs) = x : take (n - 1) xs

-- Mozno "guardovat" aj booleanovou funkciou
myFilter p (x : xs)
    | p x       = x : myFilter p xs
    | otherwise = myFilter p xs


-- Toto vrati zoznam: 3:3:1
applyTwice f x = f (f x)
applyTwice (3 :) [1]


- kvoli type-checking-u
yesno (Just _) = true
	- pozor, ze _ je arguiment kazdeho typu

(a:b:c:_) = str	

	
Dalsie priklady na definicie funkcii:
lostNumbers = [ 4, 8, 15, 16, 23, 42 ]
f n = n `div` 2
f a b c = 1
a `myop` b = a + b
x % y = reduce $ Rational x y
(Rational x1 y1) +. (Rational x2 y2) = (x1 * y2 + x2 * y1) % (y1 * y2)
replicate n x
    | n <= 0    = []
    | otherwise = x : replicate' (n - 1) x
take _ []     = []	
	
	
(,,) "exp1" "exp2" "exp3"
\x -> x+x :: Int
defMB = defValue (Nothing :: Maybe Bool)	


TYKA SA FUNCTION DEFINITION
TODO: pokial ma funkcia anotaciu, nutne zistit, ci naozaj prijima argumenty zadanych typov
	- cez typesystem
	
- Kontrolovat tieto komplikovane veci? Lebo sa daju skontrolovat, ale je to asi zbytocne...
- prejde, ale runtime error pri pokuse pouzit:
(f1, f2, f3) = (1+f1, 1+f2, 1+f3)
[1, f] = [2, 3]
- prejde bez problemov:
[2, h] = [2, 3] -- toto uz ale prejde a h ma hodnotu 3, v podstate ako funkcia
[x] = [7]




		
		
	
definition -> annotation / function-definition	
----------------------------------------------
(tato cast je vyriesena a snad sa k nej nebude treba vraciat)

- toto urcite zmienit v diplomovke
- mozno najjednoduchsie riesenie je vzdy ocakavat, ze ide o function-definition, nasledne pokial sa napise '::', pokusit sa o transformaciu

- zakladne priklady:
f :: Int
(<), (<=), (>=), (>) :: a -> a -> Bool

- po novom, analyza (de facto stavovy automat):
	- mame incomplete-command:
		- moze byt lubovolny arg
			-> pokial je len VARID, potom moze byt jak function-definition, tak annotation
				-> pridanie ciarky v tomto pripade vedie na annotation a prida novy argument
					- f, (->), g :: Int
				-> pridanie rovnitka = ci zvislej ciary | nutne transformuje na function-definition
				-> pridanie dvojbodky... je komplikovane
					f :-: g je operator-definition
					f :: g je annotation
					=> mozno sa rozhodnut este transformovat z operator-definition, ale nie je velmi moznost odchytit tuto udalost
						- mozno kombinacia s constraint, ze property nemoze byt ::? prip. netransformovat na operator-definition, pokial je to nejasne
			-> pokial nie je VARID, je nutne function-definition
			- pozor, musime umoznit transformaciu z jednoducheho arg na function-definition variantu, ci operator-definition variantu
				-> v takom pripade je tiez nutne non-annotation
		- moze byt uzatvorkovany operator, napr. (<=)
			-> vedie uz iba na annotation
			
- je nutne function-definition aj annotation spravit IDontSubstitueByDefault
- zrejme nejde inak, nez rozduplikovat klasicku "Pattern" schemu s pridanymi vlastnostami:
	- obdoba PatternWrapper
	- akakolvek transformacia, ktora by normalne viedla z PatternArgument na PatternOperator alebo PatternFunction musi zmenit cely IncompleteCommand
		- pozor, treba ich okopirovat - musi vediet vytvorit pozadovane nodes, napr. f_x musi vytvorit po napisani "x" korektne PatternFunction
	- tranformacia na PatternOperator musi byt opatrna - pokial sa napise "::", musi sa zmenit IncompleteCommand na annotation, inak na PatternOperator
		- nezabudnut zahrnut novonapisany operator do PatternOperator-u
	- transformacia napravo od PVarName pri napisani ciarky meni IncompleteCommand na annotation
	- PBracket musi obsahovat este jednu transformaciu - na uzatvorkovany operator, napr. (<=) - tym padom je ale nutne zmenit cely IncompleteCommand na annotation
	- pridane transformacie sprava od PatternArgument po napisani:
		=	function-definition
		|	function-definition
		::	annotation
	=> pozor, function-definition sam o sebe musi byt flexibilny a umoznovat napisat = alebo | dodatocne
	- v ramci annotation moze byt annotation-item jedine VARID, alebo uzatvorkovany operator
		=> vsetky transformacie normalne aplikovatelne na arg musia existovat aj tu a musia zachovavat informaciu (napr. po napisani do zatvoriek () pismeno, napr. (a) sa musi korektne zachovat, ze ide o PBracket, ktory obsahuje jeden VARID)
			- nicmenej vsetky transformacie nenavratne stransformuju aj IncompleteCommand na function-definition		
			
- cize duplikacia:
	- vytvarame abstraktny koncept FDA, ktory reprezentuje bud annotation alebo function-definition
	- ake koncepty kopirujeme od Pattern-ov?
		- t.j. ake koncepty su nejednoznacne?
		- FDABracket 
			- prazdna zatvorka
		- FDAVarName
			- premenna VARID
		- nic viac, ale na druhej strane musime vediet hned zacat pisat napr. [], alebo "mystring" pokial zaciname z EmptyLine statement-u
			- t.j. v tomto pripade chceme, aby sa okamzite vytvoril function-definition
		=> jak to docielit?
		- najprv predpokladajme, ze nechceme tento incomplete-command pattern pouzivat a ze vsetko je automaticky function-definition (annotation nateraz ignorujeme)
			- v takom pripade jednotlive koncepty, ktore dedia od pattern-u, musia akoby dedit od samotneho Definition
			- to typicky nejde, cize musime pouzit wrap substitute menu
		- teraz vieme, ze potrebujeme wrapper, ale potrebujeme umoznit len niektore patterny, ktore su jednoznacne
			- tu by teoreticky malo ist pouzit condition
			=> potrebujeme zakazat PBracket a PVarName a idealne aj PWildcard
				- PWildcard by sa asi mal chovat rovnako, ako PVarName
		- tu rozhodnutie zawrapovat PatternArgument nesie celkom silny dosledok - napr. napisanie "infixl" automaticky vytvara function-definition
			- pretoze infixl nie je alias
			=> treba opravit
			- no ale nejde to jednoducho vyriesit cez condition a owrapovat cely PatternArgument
				=> pre kazdy osobitny PatternArgument treba vlastny wrap - pre tie, ktore povolujeme (BTW, takto to uz funguje)
				- PBracket nie
				- PVariable tiez nie
		- cize je nutne este pridat 2 ambiguitne koncepty
			- FDABracket
				- po napisani akehokolvek operatoru tranformacia na annotation
				- inak transformuje na PBracket vnutri function-definition
				- jak to docielit?
					- inak, inspiracia je tu z transformacie bud na PatternOperator alebo na PatternFunction
					=> tu je zial problem s tym, ze nemozno testovat pattern v ramci can-execute, lebo nastane konflikt a bude tam transformacne menu (chceme okamzitu transformaciu)
					- tym padom musi byt vsetko vnutri "text" casti
					- a kedze "text" cast musi byt prazdna, pokial sa ma matchovat na komplikovanejsie substitucie (napr. na PVarName), tak potom pre uplne inu tranformaciu musi byt vymenovanie uplne vsetkych operatorov v jednotlivych text castiach
						- nie je nutne vymenovat, jak som posledne zistil - je nutne ale inteligentne naprogramovat text cast trasnformacie
						- t.j. porovnaj PatternArgument_FunctionTransformation a PatternArgument_OperatorTransformations
						- toto BTW treba urcite spisat do MPS-howTo
						- suvisi s bodom "Jak pridat novu bunku po transformacii tak, aby sa automaticky substituovala za pozadovany koncept?"
			- FDAVarName
				- tu je klasika - default transformation z bezneho Definition na FDAVarName, a potom sa rozhodneme na zaklade dalsich veci neskor
				- pointa je, ze sa tu nesmie s nicim kryt - napr. ak sa napise "class", co vyhovuje pre VARID, tak to ma vziat ako class a nie ako FDAVarName
					- nicmenej sa zda, ze toto MPS riesi tak nejak sam, co je dobre
					- stale je vsak nutne byt opatrny napr. pri pisani "true" alebo "false"
					
				- vsetky transformacie veduce z pomenovanej premennej:
					- annotation:				f, (->), g :: Int
						- jednoduche, transformuje sa po pridani ciarky
					- function-definition:		f = 0
						- transformuje sa po pridani symbolu =
					- annotation:				f :: Int
						- transformuje sa po pridani symbolu ::
					- operator: 				f :-: g = 0
						- transformuje sa po pridani akehokolvek ineho operator symbolu, nez ::
						- : sam o sebe aj tak nemoze stat
						- rozhodnutie je, ze v momente, ked sa uz napise ::, tak necakame, ci to nebude nahodou ::- a pod. zvasty, proste transformujeme na annotation
					- function-definition: 		f g = 0
						- po pridani akehokolvek ineho objektu za predpokladu, ze ide o samostatny VARID nalavo
						- nutne vyriesit cez text rovny ""
				- function-definition tvru f | x > 0 nemoze existovat, lebo nie je voci comu guardovat
				- tak, toto sa podarilo nejak vyriesit, najhorsie to bolo s tym operatorom, kedze tam moze byt akakolvek kombinacia symbolov okrem :: a =, co som vyriesil cez prefixovy strom
					- mozno sa o tom prefixovom strome asi vyjadrit, ide o cosi menej trivialnu zalezitost MPS
			
				- vsetky transformacie veduce z wildcardu:
					- operator:					_ :-: _ = 0
					- nic viac, cize by to bolo jednoduche... az na to, ze pokial uzivatel povodne mienil napisat _f, _g :: Int tak je to problem
					- vyhoda je, ze ked uzivatel napise _f, tak to zareaguje spravne automaticky
					- cize ide len o to vyriesit transformacie pre samotny wildcard, kym ho nikto nezmenil na VARID
					- ale pojde aj tak iba o operator
					- nemoze byt funkciou, cize to je ignorovane (funkcia musi byt striktne pomenovana)
					- tym padom odpada jak function-definition tak annotation
			
Spisat do uzivatelskej dokumentacie:
	- zial tym, jak MPS funguje (teda hlavne jak funguju transformacie s textom rovnym ""), po napisani zatvorky () je nutne najprv stlacit
	medzernik a az potom nieco zadat
	- t.j. napr. toto ( [) aby sa previedla trasnformacia na toto ([]) =
	- pre operatory to funguje inak (ale tam nemame text rovny "" - tam su konkretne hodnoty)
				
			
FunDef
	- pridane transformacie sprava od PatternArgument po napisani:
		=	function-definition
		|	function-definition
	=> pozor, function-definition sam o sebe musi byt flexibilny a umoznovat napisat = alebo | dodatocne
			
	- treba aj na operator definition vediet pridat guardov alebo definiciu
	- pozor, pre operator =/=, musi to riesit inak:
	x =/= y = 0
	...by vyhodilo okamzite:
	x = /=y 
	- pozor, plati aj pre zvislitko |, cize som ho tiez pridal medzi exceptions
	- pokial by mala byt uzivatelska privetivost, ze by sa mal mat moznost sam rozhodnut, tak sa da nastavit:
		default transformation menu for concept FDAVarName
		- cast:
		list<string> exceptions = (editorContext, node, model)->list<string> { 
			return new arraylist<string>{"::", "=", "|"}; 
		}
	- tak som to skutocne nechal ambiguitne, aby si uzivatel mohol vybrat, ze co chce v danom pripade
	- nicmenej, keby sa mi to nepacilo, staci pridat do premennej exceptions dane dva stringy, t.j. "=" a "|"
		- ide o tieto tranformacie:
			default transformation menu for concept FDAVarName
			transformation menu PatternArgument_OperatorTransformations for concept PatternArgument
			
			
- function-definition a annotation by mali byt IDontSubstitueByDefault
				
- pridane intentions na urovni definition pre vlozenie:
	- anotacie
	- operator definition (guards)
	- operator definition (assignment)
	- function definition (guards)
	- function definition (assignment)
- su pridane kvoli tomu, ze ctrl + space napoveda tieto veci neobsahuje, lebo sa buduju postupne



if-then-else
------------
- zaklad
yesnoIf x yesResult noResult = if x > 100 then yesResult else noResult
	- jednoduche expression a netreba ziadne specialne akcie
	- zostava tu specialne kontrola, ci zadany expression v podmienke je skutocne typu Bool

- pozor na referencovanie, kedze referencovane objekty mozu byt vytvorene neskor, nez su pouzite
respondPalindromes = unlines . map tellPalindrome . lines where 
	tellPalindrome xs = if isPalindrome xs then "palindrome" else "not a palindrome"
    isPalindrome xs = xs == (packed . reverse . unpacked) xs
	- tu by som povedal, ze to uzivatel skratka musi napisat v spravnom poradi: najprv definovat "isPalindrome" a az potom mu je dovolene to pouzit
	


expression transformacie celkom
-------------------------------
- poriesit operatory
	- zaprve, budem ich vobec referencovat?
		- velmi zavisi od typoveho systemu, jak bude prevedeny
		- typ sa moze odvodzovat jednak podla anotacie, ci indukovat z definicie funkcie
		- nicmenej, stale by to znamenalo, ze nioektore operatory musia byt vstavane, obzvlast pre Integery a Double
	
	- jak zostavit ten strom?
		- prechod by mal byt podla priorit operatorov
		- to sa vsak moze ukazat celkom nemozne, pretoze ich priorita sa moze menit za behu a to je problem
			- myslim na fixity
		- jedine, na co sa mozem spolahnut, su zatvorky, cize tam vytvorenie stromu ma zmysel
		- je mozne, ze budem musiet upravit gramatiku a nemat operatory v podobe stromu, no...
		- vid toto: http://www.csinaction.com/2015/03/31/custom-infix-operators-in-haskell/
		- predpokladajme teda priklad s tym, ze operatory su prioritne takto: / * - +
		a + b * c / d - e + f * d - g
		
		(a + (((b * (c / d)) - e) + ((f * d) - g)))
		- hovori sa tejto priorite precedencia a je definovana napr. vo vyraze infixr 4 `/`  infixr 3 `*`  infixr 2 `-`  infixr 1 `+`
			- t.j. + ma najnizsiu precedenciu
		- specialne, aplikacia funkcie ("operator medzera") ma precedenciu 10, ktoru nemozno prebit (najvyssia pre operatory je 9)
			- cize:
			f a * b
			- je vzdy:
			(f a) * b		
			- cize tu tiez ma zmysel vytvorit strom, lebo precedencia sa nezmeni
		
		- co takyto vyraz, jak ma vyzerat strom?
		a + b + c + d + e + f
		- zavisi od asociativity; pokial je lavo asociativny, tak:
		(((((a + b) + c) + d) + e) + f)
		- a naopak, pravo asociativny:
		(a + (b + (c + (d + (e + f)))))
		- pre infix (bez l aj r):
			- fatal error - nedefinovana asociativita, cize nejde prelozit
			- nicmenej, vyraz a + b * c by siel prelozit bez problemov, lebo obsahuje len jedno plus
		- pokial su operatory rozne, ale maju rovnaky precedence, tak sa asi beru zlava (striktne)
			- napr. 5 + 1 - 7
		- co teda celkovo s tymto?
			- bud by slo odchytit udalost zmeny precedencie vo vyraze infixl ..., ale to pochybujem, ze MPS dokaze
			- cize nemoze ist o bezny strom, ale o zoznam poloziek, ktory sa parsuje, idealne nejak rychlym algoritmom, dodatocne
				- prejdem polom a usporiadam operatory podla priority (triedenie)
				- da sa vsak aj na 1 prechod pouzitim zasobnika
	
					a + b * c / d - e + f * d - g
					- vyrazy sa aj tak vyhodnocuju zlava doprava
					- akurat, ze napravo moze byt operator s vyssou precedenciou
					- cize myslienka je, ze pockam s aplikovanim sucasneho operatora, dokym sa neuistim, ze operator napravo nema nizsiu 	
						ci rovnu precedenciu
						a - b * c + d
					- cize tu netreba triedit
					
					lavo asociativne */-+
					((a + (((b * c) / d) - e)) + ((f * d) - g))
					((a + (((b * c) / d) - e)) + ((f * d) - g))
		
		- predpokladajme, ze + je lavo asociativny, * pravo a maju rovnaku precedenciu
			1 + 2 + 3 = (1 + 2) + 3		-- lava asociativita
			1 * 2 * 3 = 1 * (2 * 3)		-- prava asociativita
			
			1 + 2 * 3 + 4 * 5 * 6 * 7 + 8 + 9 * 10 + 11
			
			(1 + 2) * 3 + 4 * 5 * 6 * 7 + 8 + 9 * 10 + 11
			- idem zlava; * ma rovnaku precedenciu, ako +, lenze + je lavo asociativny,
			takze vykonam
			
			((1 + 2) * 3) + 4 * 5 * 6 * 7 + 8 + 9 * 10 + 11
			- narazim na +, co je ale iny operator, a som pravo asociativny, lenze je iba jeden
			prvok, tak vykonam
			
			((((((((1 + 2) * 3) + 4) * (5 * (6 * 7))) + 8) + 9) * 10) + 11)
			
			overme:
			infixl 7 +-+
			infixr 7 -+-
			
			a +-+ b = (a - b) + 10
			a -+- b = (a * b) - 7

			1 +-+ 2 -+- 3 +-+ 4 -+- 5 -+- 6 -+- 7 +-+ 8 +-+ 9 -+- 10 +-+ 11
			((((((((1 +-+ 2) -+- 3) +-+ 4) -+- (5 -+- (6 -+- 7))) +-+ 8) +-+ 9) -+- 10) +-+ 11)
			- tak je to jasne:
				invalid expression, right-associative operator -+- found on same level as left-associative operator +-+
				- pozor, chyba vyskoci len v pripade, ze je ich precedencia rovnaka


				
- aplikacia lambda funkcii
	- treba si uvedomit, ze skoro vsetko je aplikacia funkcie
	- bezna premenna referencovana zlava je tiez aplikacia funkcie
		vid definiciu map:
		map f (x:xs) = (f x) : (map f xs)
		- f sa mozno tvari ako premenna, ale je to funkcia

	(\x -> \y -> \z -> x + y + z) a b c
	((\x -> \y -> \z -> x + y + z) a b c)
	- opat typova kontrola v ramci moznosti, aj na pocet argumentov
	
	f = (\x -> x+1) 1
	
	- upozornime, ze toto ale vyhodi chybu pri preklade:
	ff = \x -> x + 1 1
	- cize nic nepokazime tym, ze tam tie zatvorky budu striktne pri kazdom vytvoreni lambdy

	
	fa f x = f x
	g = fa (\x -> x+1) 1

	h = fa ((\x -> x+1) 1)  -- toto nepojde prelozit! 
							-- totizto vyraz ((\x -> x+1) 1) vracia 2, co urcite nie je funkcia prijimajuca 1 argument
	

	g x = x + 1
	f = g ((\x -> x+1) 1)
	

	g x = x+1
	f = g (\x -> x+1) 1		-- toto nepojde prelozit: too many arguments
							
						
	Dolezite pozorovanie:
	-  vsetky argumenty vzdy pozerie prva funkcia nalavo, inak je treba uzatvorkovat (pricom uzatvorkovany vyraz predstavuje samostatny argument)
		
	- je to teda jasne: 
		- kazdy expression je vzdy aplikaciou funkcie
		- funkcia je proste funkcia, pripadne konstruktor, co je len ina funkcia
		- vsetky argumenty zadane napravo vzdy pozerie, v ramci stromu ohranicenom najblizsou zatvorkou
		- skratka, pokial mame vyraz, ktory mozno napisat takto:
			f = a b c d e g h i j k where
				a = ...
				b = ...
				...
			- vdaka where vsetko mozno takto prepisat
			- tu vzdy bude a funkcia, na ktoru sa pokusime aplikovat argumenty napravo
			- pokial ale pocet argumentov bude vacsi, nez a je schopne prijat (napr. Int je konstantna funkcia, ktora prijima 0 argumentov, cize nesmie byt napravo ziaden), tak to failne (cize tu cez typsystem bude nutne okontrolovat)
		
	- zostava ale problem, jak to skombinovat s operatormi a dalsimi funkciami
	- a co este ak mame vyraz typu a b c d e f g h i kde napr. e aj f su funkcie tiez prijimajuce argumenty?
	- tak najprv ta druha otazka:
		f x = x + 1
		g = f f f 1			-- f je lavo asociativne, cize sa snazi pozrat vsetky argumenty napravo, co ale sposobi chybu pri preklade
		g = f (f (f 1))		-- tu je to OK
		
		h x y = x + y
		g = h f 1 f 2		-- tiez nefunguje

		- pre istotu este tieto priklady:
		f x y = 0
		g x y = 0
		h = f 1 g 2		-- nejde prelozit
		h = f 1 g 2 3	-- tiez nejde prelozit
		h = f 1 (g 1)	-- funguje
		
	- lenze kombinacia s operatormi?
		j = f 1 + f 2		-- prejde, bez problemov! + totiz nie je argument, ale operator, co ma specialne postavenie
		- otazka je teda, co sa stane, ked poskytneme viac alebo menej argumentov
	
		f x y = x + y
		g = f 1 + 2 2		-- nejde prelozit!
							-- momentalna teoria: f prijima 2 argumenty, cize f 1 vrati funkciu prijimajucu 1 argument
							-- nicmenej 2 je konstantny funkcia a vyraz 2 2 nejde prelozit, a uz vobec nie nascitat s funkciou jedneho argumentu
							
		f x y = x + y
		g = f 1 + 2			-- samozrejme nepojde prelozit, ale hlavne kvoli nekompatibilnym typom, t.j. "f 1" a "2", na co + nie je 
							definovane
		
		g = f 1 + 2			-- uz prelozit ide
		
		f :-: g = f
		f x y = x + y
		g = f 1 :-: f 2		-- tiez ide prelozit! cize potvrdzuje teoriu, ze funkcia zerie argumenty, az dokym nenarazi na operator
							-- cize je to tak, ze funkcia sa tiez chova ako operator
		
		g = f 1 2 :-: f 2 3	-- tiez prelozi
		
		g = f 1 2 3 :-: f 2 3 4
		g = f 1 2 :-: f 2 3 4
		g = f 1 2 3 :-: f 2 3
							-- ani jednu z variantov neprelozi
							
		
		f x = x + 1
		g = f (+) 1 2	-- neprelozi, snazi sa totiz pozrat
		g = f 1 + 2		-- ok					
		
	-- toto mi tiez funguje:		
	-- note: povodne toto nefungovalo (ale je asi dane poskodenym compilerom)
	ff f x y = f x y
	hh x y = x + y
	gg = ff hh 1 2
	
	-- tak uz toto tiez normalne funguje:
	ff f x y = f x y
	hh x y = x + y
	gg = ff (+) 1 2
		- weird stuff proste
		- uzatvorkovany operator je teda normalna funkcia, a chova sa bezne ako argument
	
	- zostava teda este chovanie operatorov:
		(1 +) :-: (1 -)			-- ok
		(+) :-: (-)				-- nie je ok, ale je to skor z toho dovodu, ze ide o ambiguity: :-: vracia funkciu, ale (+) je akoby inej 
									"charakteristiky" (typu), nez (-)
		
	- toto je tiez ok:
		f = 1 * (+) 7 8			-- (+) je funkcia, cize ma vacsiu precedenciu, nez *, co je operator
	
	- funkcie teda zeru argumenty, dokym nenarazia na operator z pravej strany (uzatvorkovany operator je ale argument)
		- pokial narzai na funkciu, aj tak ju pozerie ako argument
			
	- pozor, este co s definovanim (f x y) :-: (g x y)? (ci takto mozno definovat operator)
		- nie, neda sa aplikovat funkciu v patternoch
	
	- pridajme este, ze konstruktory pre datatypy su skoro identicke beznym funkciam, tiez pozeru argumenty napravo:
		data MyData = Wide Int Int | Narrow String
		f = Wide 7 4 + 3			-- neprelozi, t.j. nie je definovane scitanie pre tym MyData a Int
		f = Wide 7 4 :-: 3			-- ok
		f = Wide 7 (+) 4 3			-- neprelozi, (+) nema ziadnu prednost - je to pozraty argument funkciou "Wide"
		f = Wide 7 ((+) 4 3)		-- ok
	
	- teraz pohlad do oficialnej gramatiky:
		topex ::= ('if' expr 'then' expr 'else' expr | 'let' letdefs 'in' expr |'case' expr 'of' calts | (('!'|'?')* primary)+
		- topex je specialny 1 konkretna jednotka expression, napr. if
		- maximalne este obsahuje aplikaciu funkcie, cze primary+
		
		primary ::= term | VARID | '[' expr ']' | '(' expr ')'
			- uzatvorkovany epxression je v poriadku
		
		binex ::= (binex (SOMEOP|'-'))* '-'? topex
			- pokial je tu operator, musi byt ohraniceny vzdy dvomi TopExpressions
		
		-- a aby nedoslo k tymto problemom:
		f x = x+1
		g = f if 1 > 0 then 1 else 0
		- tak nie je mozne, aby argument funkcie bol TopExpression, iba term
	
		g = if 1 > 0 then 1 else 0 + 1
		g = if 1 > 0 then 1 else (0) + 1
		- vracia 1, cize 0 + 1 aj (0) + 1 spada pod else vetvu
		- if je specialny pripad TopExpression, pre ktory sa to chova takto
		
	
- premenne
	- na lavej strane by premenne nemali byt rovne nasledujucim menam:
		- 'if', 'then', 'else', 'let', 'in', 'case', 'of'
		- okontrolovat, ci rezervovane slova sedia
	- na pravej strane premenne mozu byt iba referencovane, pokial neboli pridane v ramci nejakeho let, ci where
		- vzdy vsak musia byt referencovane

	
- tranformacie:
	- where musi byt vzdy "transformovatelny", t.j. kedykolvek by malo ist pridat "where" z pravej strany vyrazu

	
	
expression
----------
- zaklad gramatiky
expr ::= exprPart ('::' rho)?
exprPart ::= topex | binex 
binex ::= exprPart SOMEOP exprPart

- je nutne zistit, jak je to presne s unarnymi operatormi, udajne je len jediny unarny operator a to minus

- stale neviem, ci sa oplati referencovat operatory, zatial radsej nie

- po zadani '::' napravo od exprPart pridat "rho"
	f = (3 :: Int)
	- asi pre istotu mozno pridat zatvorky

- pri pisani sa vzdy vytvori topex
- pri zadani medzery a nejakeho operatoru z dostupnych:
	#  $  %  &  *  +  .  /  <  =  >  ?  @  \  ^  |  -  ~ :
	napr. x * y * z
	- sa prevedie na binex
	- operatory by sa nemali konfliktovat (koniec koncov je tam zadana medzera)
	- problem tu moze byt so symbolom ':', ale ako som pisal, tym, ze je to zadane uplne napravo + medzera, by to malo byt zrejme
		- navyse v pripade "f (x : xs) = x*2 : (f xs)" sa chape ako operator
	- operatory by asi tiez mali byt referencovatelne, ale potom pozor na vstavane operatory (+ - * / a pod.)
	
- typesystem pre spravne typy operandov
	- pouzitie operatorov je ako pouzitie funkcie, ktore ocakavaju argumenty isteho typu a vracaju vyraz isteho typu
	- napr. "1 : []" vracia vyraz typu list
	
	
	
topex TODO
-----
- zaklad gramatiky
topex ::= 	'if' expr 'then' expr 'else' expr
			'let' letdefs 'in' expr
			'case' expr 'of' calts
			lambda
			(('!'|'?')* term)+

- dane transformacie podla toho, co uzivatel zacne pisat:
	- if
	
	- let
	
	- case
	
	- lambdy
		'(' \x -> \y -> \z -> x + y + z ')'
		- po napisani '\'
		- vzdy sa aj ozatvorkuje
		
	- term+
		- list
			- '['
			- "f (x : xs) = x*2 : (f xs)"
				- tu je to ale binary expression, ':' je operator
		
		- bracketed expression
			- '('
			- t.j. '(' expression ')'
			- navrhujem pridat intention, aby sa akykolvek expression dal obalit, ci vybalit, zo zatvorky
			- do diplomky mozno zmienit, ze niekedy by bolo ziaduce mat incomplete-command s jedinou zatvorkou, aby bolo mozne tvorit vyrazy typu "(x + 1" a az potom napisat pravu, ale ze na to uz nezvysil cas
		
		- tuple
			- '(' vytvori brackets:
				- '(' expresion ')' 
				- cize napravo pri napisani ',' od expresion vytvori tuple
		
		- literal
			- _: pridame podtrzitko
			- true, false: BoolValue (pozor, dokym nie su napisane cele, nie je mozne urcit, pretoze mozno pojde o pVariable)
			- cislo: IntValue, prip. DoubleValue (treba este raz zistit presny format)
			- napisanim apostrofu ' je jasne, ze ide o CharValue
			- napisanim uvodzovky " je jasne, ze ide o StringValue

		- premenna
			f x = 2 * x
			- x nie je ani literal, ani funkcia
			- malo by byt referencovatelne
		
	- aplikacia funkcie
		'(' f [1, 2, 3] ')'
		- referencovanim mena funkcie sa prida tento node
		- pre jednoduchost obalime do zatvorky
		- argumenty mozno pridavat napisanim cohokolvek napravo (prida sa prazdny expression)
			- nerobi problem, lebo sme uzatvorkovali do specialneho node-u
		- typova kontrola na to, aby sme nepresiahli pocet argumentov a aby boli argumenty spravneho typu
		
	- aplikacia konstruktoru
		g = '(' Point 1 2 ')'
		f = '(' Circle (Point (1 + 2) (2 + 3 :: Int)) 7 ')'
		- referencovanim mena konstruktoru sa prida tento node
		- funguje inak rovnako, ako aplikacia funkcie
			
	- aplikacia operatorov ako funkcii
		- aby sme to nekomplikovali, pokial sa ocakava expression, tak napisanim operatoru ho transformujeme na tento konstrukt (pridame aj zatvorky)
		- pokial by uzivatel napsial najprv zatvorku a potom napisal operator, tak si vsimne, ze to prida viacej zatvoriek, t.j. vytvori toto '(' '(' + ')' ')', a tak uz to bude pouzivat rozumnejsie
			- do diplomky mozno zmienit, ze to ide aj lepsie, len sa nam tym nechce zaoberat
		- funguje inak rovnako, ako aplikacia funkcie
		- asi je vsak nutna referencia operatorov
		- co potom s implicitnymi operatormi, ako + - * /? asi je nutne ich natvrdo "zadratovat"
		'(' + ')' 1 a
		map (*) [0..]
		filter ((==) 3) [ 1, 2, 3, 4, 5 ]
	
	- aplikacia lambda funkcii
		(\x -> \y -> \z -> x + y + z) a b c
		- transformuje sa z beznej lambda funkcie, prip. moze byt nou, len s prazdnym argument list
		- transformacia tym, ze sa napise "medzera a hocico" napravo od lambdy
			- to "hocico" vsak nesmie byt rovne operatorom
			- toto je overene, t.j. vyraz "f = (\ -> 1) + 1" nie je platny
			- pridava sa, dokym uzivatel konecne nenapise operator
				- pozor, binex sa vytvori ale na urovni samotneho argumentu, aby to odpovedalo realite
				f = (\x -> 1 + x) 1 * 1
				1 * 1 by malo byt na urovni argumentu pre lambdu, t.j. "f = (\x -> 1 + x) (1 * 1)", a nie na urovni "f = ((\x -> 1 + x) 1) * 1"
		- opat typova kontrola v ramci moznosti, aj na pocet argumentov

- tymito prikladmi sa nebudem zaoberat, lebo mi nicia uz vytvorenu gramatiku:
f x = (x+)			
f x = (-x)

- problemy pre riesenie v ramci typesystemu

	- currying
	f x y = x + y
	g = f 0
	h = g 1
		- je nutne vediet detegovat aj typ "funkcia prijimajuca n argumentov"
	
	filter ((==) 3) [ 1, 2, 3, 4, 5 ]
		- toto je identicke prikladu vyssie
	
	- specialne vstavane operatory
	(,,) (x > 0) (x % 2 == 0) (x % 3 == 0)
		- navonok ako klasicka aplikacia operatoru ako funkcie
		- tu ide ale o aplikaciu konstruktoru (tuple)
		- nie je vsak nijak odlisna od beznej funkcie, t.j. ide o funkciu prijimajucu 3 argumenty, ktora vracia tuple (3-ticu)
		- tu je vsak problem ten, ze tento operator je vstavany a ze ma nekonecne vela variantov, t.j.:
			(,,) - vytvara tretice
			(,,,,,) - vytvara 6-tice
			atd.
		- je ich nutne nejak zadratovat? ja vsak navrhujem tento operator vobec nepodporovat
	
	
	
let
---
- zaklad
f x = let a = w x in 
	if cond1 x then a else f (h x a)
 
encode shift msg = let 
	ords = map ord $ unpacked msg
    shifted = map (+ shift) ords
    in 
	packed $ map chr shifted

shortLinesOnly input =
    let allLines = lines input
        shortLines = filter (\line -> length line < 10) allLines
        result = unlines shortLines
    in  result
	- v podstate tu nic nie je, jednoducho definicie funkcii a anotacie
	- potom ich pouzitie (cize referencovanie), co je inak klasicky expression
	- ci pojde o anotaciu alebo function-definition, na to pouzijeme akcie z cast definition


	
case
----
- zaklad
head xs = case xs of
    [] -> error "No head for empty lists!"
    (x : _) -> x
	- je tam klasicky "expression", cize nan sa budu akcie aplikovat rekurzivne
	- nasledne je nutne mat pripraveny zoznam, na kazdom riadku jeden a moznost vytvarat dalsie enter-om
	- potom je tu pattern (opat, akcie pre upravy pattern-u uz by mali byt v tomto bode nadefinovane)
		
- ina verzia, s guard-ami
strcmp s1 s2 = 
	case (s1, s2) of
		([], []) -> true
		(s1:ss1, s2:ss2)
			| toUpper s1 == toUpper s2 		= strcmp ss1 ss2
			| otherwise						= false
		_ -> false
		- cize na vyber su 2: "->" a "|" a je nutne tomu prisposobit akcie
		- navrhujem, aby sa standardne vytvorilo "->", co je najcastejsie
		- potom mozno zmenit cez intentions na "|" variant
		- treba sa o tom zmienit v diplomke, ze existuju rozlicne pristupy a zalezi len na nas
			- mozno by bolo krajsie, keby sa to vyriesilo opat cez incomplete-command, ale je to vyrazne pracnejsie
	
- unita, t.j. znak () v tomto priklade
f x = let a = w x in case () of 
			_ | cond1 x   -> a
			  | cond2 x   -> g a
			  | otherwise -> f (h x a)
	- bud ako specialny koncept (tym padom bude nutne vytvorit este specialny wrapper nad expression)
	- pripadne uplne odignorovat, pretoze je to menej typicke

- tu mozno typova kontrola, ze jednotlive cases su rovnakeho typu, ako expression pouzity v ramci case
	
	

lambda
------	
- zaklad
f = map (\x -> 2*x) [1 .. 10]
	- pridavanie jednotlivych argumentov cez "\"
	- prava strana je klasicky expression

- priklad demonstrujuci viacere argumenty
flip f = \x \y -> f y x

- pozor, lava strana je pattern
j = (\(x:xs) -> (2*x : xs)) [1..5]
f x = (\(a,b,c) -> a+2*b+3*c) (x,x,x)
	- cize len uplatnit rekurzivne pravidla pre pattern-y
	- cela lambda je aj tak zabalena do zatvoriek, cize by sa nemalo s nicim konfliktovat

	
	
list TODO (len "TODO: co moze byt nalavo?")
----
- je term
- zaklad
[ 1, 2, 3, 4, 5, 6, 7 ]
	- po stlaceni "," prida novy prvok
	- potrebna typova kontrola, ze vsetky prvky su rovnakeho typu (prvy prvok urci typ, ostatne musia byt rovnake)

- prvky zoznamu su rekurzivne vyrazy (expression)
[ [ 5, 4, 5, 4, 4 ], [ 1, 2, 3 ], [ 3, 5, 4, 3 ], [], [ 2 ], [ 2, 2 ] ]
	- vediem len ako priklad, nie je nutne nic specialne pridavat
	
- range:
['K' .. ]
['K' .. 'Z']
[20, 19 .. 1]
	- transformacna akcia po napisani ..
	- posledny prvok je optional a po napisani cohokolvek prebehne transformacia
	- aj tu typova kontrola, ze koncovy prvok po .. je rovny prvemu
	
- list comprehension
[ [ x, y, z ] | x <- [ 1, 2 ], y <- [ 3, 4 ], z <- [ 5, 6 ] ]
	- najprv sa napise '[', co vytvori bezny zoznam '[' ']'
	- vnutri zoznamu po stlaceni '|' napravo od expression vytvori list comprehension, pokial este nebol transformovany na '[' expresion1, expresion2 ']'
	- prava strana ma polozky viacerych druhov
		- oddelovat po napisani ","
		- tu treba rozlisit medzi tromi typmi
			[ (c, z) | c <- str, c `elem` ['A'..'Z'], let z = min a b]
			- boolean expression, napr. c `elem` ['A'..'Z']
				- typova kontrola, ze ide o boolean expresion
			- priradenie, napr. c <- str
				- typova kontrola, ze prava strana vracia zoznam
				- lava strana:
					- moze byt premenna
					- moze byt _
					- moze byt aj typu (a, b) <- xs
					TODO: co moze byt nalavo?
					
			- let, napr. let z = min a b
		- tu by tiez slo priradit rozlicne akcie, aby sa prevadzala postupna transformacia z nejakeho incomplete-command
		- nicmenej to tu nebudeme robit
		- prinutime uzivatela, aby stlacil ctrl + space
		- do diplomovky napiseme, ze to ide, demonstrovali sme to na priklade function-definition a annotation, ale ze tu by slo o dalsiu pracu
		
		

guards	
------
- zaklad
replicate n x
    | n < 0			= 2 * x
	| n > 0			= 3 * x
	| otherwise 	= 4 * x

- otherwise by mal byt novy koncept, ktory je mozne doplnit namiesto boolean expresion

- ci ide o boolean expression je nutne okontrolovat cez typesystem

- ohladom predolseho bodu treba doplnit, ze niekedy nie je nutne zadat symbol '=' pre transformaciu na function-definition, ale aj '|'

- zadanim '|' by sa mal pridat novy guard



where
-----
- zaklad
describeList xs = "The list is " ++ what xs where 
	what []  = "empty."
    what [x] = "a singleton list."
    what xs  = "a longer list."
	- nasleduju potom jednotlive function-definition a anotacie funkcii
	- cize len rekurzivne uplatnit to, co uz bolo zname vyssie
	
- where musi byt mozne lahko pridat napisanim "where" (transformacia)
			
			

class
-----
- zaklad
class Eq a where
	(==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool  
    x == y = not (x /= y)  
    x /= y = not (x == y)
	yesno :: a -> Bool
	- za nazvom triedy je bud typova premenna, prip. referencia na existujuci typ ("data", "type", String, ...)
		- napr. "class Eq String"
	- jednotlive polozky po where uz su popisane v casti "where", takze by nemalo ist v tomto bode o ziadnu dalsiu pracu navyse
	- nazov triedy sa nesmie zhodovat s uz existujucim nazvom
		
- kontext
class (Eq a) => Ord a where
  (<), (<=), (>=), (>)  :: a -> a -> Bool
  x >= y				= (not (x <= y)) || (x == y)
  x < y               	= (x <= y) && (x /= y)
  x > y               	= not (x <= y)
	- kontext musi ist rychlo pridat pri napisani zatvoriek
	- kontext referencuje existujucu triedu (napr. Eq, Ord, prip. uz napisanu v ramci daneho programu)
	
	
	
instance
--------
- zaklad
instance YesNo Int where
    yesno 0 = false
    yesno _ = true
	- trieda YesNo uz musi byt nadefinovana, t.j. tu je jednoznacne referencovana len a len trieda a musi existovat
	- dalsi parameter je typ (vid typovanie), moze byt napr. Int, [a], Bool, String, (Maybe a) a i.
		- tzn. ze uz vyrieseny bol (co sa tyka akcii), takze by to nemala byt ziadna dalsia praca
	- zvysok je podla "where", t.j. klasicke funkcie a anotacie
	- nicmenej, je tu dolezity type-check
		- v ramci tejto instancie musi byt nadefinovana funkcia prijimajuca typ Int, + maximalne parameter _
		- a nie je zatial jasne, jak to urobit
		- kazdopadne sa tu asi mozu objavit len funkcie z prislusnej class a nic navyse...? treba overit

- dalsi priklad ako demonstracia pre type-checking	
instance YesNo [a] where
    yesno [] = false
    yesno _  = true
	- musi prijimat zoznam daneho typu
	- cize asi je nutne nahliadnut do definicii odpovedajucemu class, pozriet sa, ake argumenty dana funkcia pozaduje a okontrolovat ich oproti zmienenym, tu oproti: [a]
	- co tym myslim, napr.:
		class Eq a where
			(==) :: a -> a -> Bool
			(/=) :: a -> a -> Bool  
		- tak potom "instance Eq Int", ktory pretazuje funkciu (==), musi mat akoby anotaciu zodpovedajucu "(==) :: Int -> Int -> Bool"
	
- pozor na kontext
instance (Eq m) => Eq (Maybe m) where
    Just x  == Just y  = x == y
    Nothing == Nothing = true
    _       == _       = false
	

	
indentacia
----------
- pokial zostane cas, zatial ju vsak neriesim
- do diplomovky mozno zmienit, ze to ide vhodnym nakonfigurovanim editoru