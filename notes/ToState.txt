Osnova:

- Motivácia (nemusí nutne byť, tu je len odpoveď na otázku "prečo som to robil")
- Vysvetlenie MPS, v skratke
	- Čo to je MPS, rozdiel medzi projekčnými a textovými IDE
	- Práca s MPS, structure, editor, behavior, constraints, typesystem
	- (odkazy na zdroje)
- Analýza 1: Gramatika
	- Pár základných rozdielov medzi Haskell a Frege (možno vynechám...?)
	- Oficiálna gramatika Frege (odkaz na zdroj, príp. ako príloha v Diplomke)
	- Čo som chcel z gramatiky zachovať (aký subset - highlevel pohľad)
	- Detailnejší pohľad na to, ako som k finálnej gramatike došiel (prečo som vysekal, čo som vysekal, priamo nadväzuje na highlevel pohľad a prečo niektoré veci nešlo vyseknúť; jak to spolu súvisí)
- Analýza 2: Gramatika pre MPS
	- Zhruba, jak sa to tranformovalo do gramatiky, ktorá nakoniec je v MPS
	- Vysvetlenie, že niektoré veci šlo urobiť viacerými spôsobmi a jednoznačný neexistuje
		- vezmime ako príklad lambdy, \x \y -> x + y
		- môže ísť o gramatiku:
			lambda ::= \varname body
			body ::= lambda | ...
		- príp.:
			lambda ::= (\varname)+ body
			body ::= ...
	- Zdôvodnenie niektorých rozhodnutí a pod.
- Akcie transformácie, editor
	- Detailnejšie vysvetlenie, jak MPS editor pracuje, jak sa preň programuje, čo dokáže a jeho limity
	- Jak sa programovali niektoré časti editoru, prečo sa programovali, ako sa programovali, spomenutie niektorých patternov (ku ktorým som sám dospel)
		- (Dedičnosť a prevzatie transformácií od rodičovských konceptov, "if applicable")
		- (Časť "text" v rámci transformácií, jak reaguje na užívateľom zadaný text a trik s "getMatchingTextForCombinations")
	- Spomenutie, že MPS nemá dostatočnú dokumentáciu na tieto veci, príp. že ich nejde urobiť inak veľmi rozumne
	- Porovnanie user-friendliness oproti textovým IDE
		- klady a zápory oboch
		- poznámka, že v konečnom dôsledku pre efektívne používanie MPS IDE pre akýkoľvek netriviálny jazyk (Frege, Java, ...) sa to musí užívateľ dostatočne naučiť
			- niektoré veci napr. nejde urobiť, ako v bežnom jazyku a je nutné sa spoľahnúť na intentions (viď "Make abstract" časť "Behavior" pri definovaní nových metód)
- (Referencie, Typesystem)
- Užívateľská dokumentácia
	- Základ - snaha bola o čo najprirodzenejšie písanie kódu
	- Niektoré veci by už boli pracné, čiže to nepodporuje úplne všetko ("limitácie")
		- napr. f x y = x + y
		- je to problém zmeniť na f x y :: Int -> Int -> Int (šlo by dorobiť, ale pracné - skrátka, nepodporuje to všetko)
	- Menej intuitívne obmedzenia - intentions, jak napísať určité bloky kódu, a pod.
	- (Limitácie má aj vstavaný jazyk Java v MPS, tiež nejde meniť všetko - počíta sa len s najčastejšími prípadmi, napr. node<> vs. node + enter + <>)
- Bokom:
	- čo mi chýbalo v MPS, napr. editor by určite zniesol väčšiu flexibilitu, ktorú MPS v tejto chvíli nepodporuje, taktiež MPS nepodporuje triedy, iba na úrovni konceptov, čo potom špiní zdrojový kód, návrhy na vylepšenie
	- pomerne nedostatočná dokumentácia MPS (časť "transformácie" a "editor") - bez ďalších zdrojov sa prakticky nedá vyriešiť inak, než "hádaním"
- Popis príloh
- Citácie

Ešte neviem, jak presne oddelím od seba časti "Analýza" a "Implementácia", zatiaľ mi skôr išlo o to, o čom sa chcem vyjadriť, ale presné poradie ešte neviem.

------------------------------------------------------------------------------------

Par veci, o ktorych sa mozno v diplomke vyjadrit:

- editor v MPS je asi neprakticky, ma malo funkcii, prip. sa user-friendliness dizajnuje tazko
	- repetetive usage (t.j. viackrat napisat to iste), ze to blbne (vid paddingy) a celkovo chyba plynulost z klasickych IDE
	- celkovo by som povedal, ze by sa to mohlo v MPS zlepsit, urcite sa to zatial ubera spravnym smerom, ale oznacil by som to za jednoznacne najvacsi nedostatok MPS (a trochu aj sklamanie)
	- cize v tejto chvili pre dizajnovanie DSL sa to hlavne uzivatelovi musi stat za to sa naucit nie uplne jasny sposob pisania kodu
		- neustale stlacanie ctrl + space ...
		- musi mat prehlat o tom, v jakej chvili kam posunut karet a jaku klavesu stlacit, aby sa vytvorilo presne to, co potrebuje, ...
	- ked sa to naucit, je to skutocne plynule a dokonca plynulejsie, nez klasicke IDE a to aj ked maju featury, ako je "surround with" a rozlicne extrahovania getters/setters a dalsie vymozenosti
		- ale naucit sa to pouzivat ale nieco stoji
	- toto sa netyka velmi specifickych DSL (jazykov), kde je menej konceptov, ale Haskell medzi ne nepatri - ma prilis rozsiahlu a komplikovanu gramatiku, cize tu je ten editor skutocne velmi limitujuci
	- co by som navrhol pre zlepsenie MPS editoru:
		- transformacie konceptov - pokial sa urci na nejaky abstraktny, tak aj vsetky konkretne by mali vediet prebrat tuto transformaciu
			- toto je vazne problem v DRY (dont repeat yourself), programator sa upise k smrti, nehovoriac o maintainability
		- nechapem, preco sa v editore neda zavesit transformacna akcia na akukolvek bunku, ale len na constant cells a properties
			- preco? fakt, preco? toto je jednoznacne ta najhorsia vlastnost, s ktorou som sa stretol
		- medzera sa chape ako specialny znak a nie vzdy funguje dobre pre transformacne akcie
			- idealne ziaden znak by nemal mat specialne postavenie
			- akekolvek stlacenie akehokolvek klavesu by malo vyvolat test, ktory prejde v transformacnej akcii, a pokial sa vyhodnoti ako true, potom sa aplikuje akcia
			- s tymto suvisi aj nepraktickost, ze transformacie mozno mat vylucne ako "left" a "right", pretoze obcas sa vazne chce mat nejake zo stredu
		- IncompleteCommand je casty pattern pre dizajnovanie dobrych editorov, je vazne skoda, ze nie je priamo v MPS implementovany (stacilo by, ak by slo len o interface, ktory sa implementuje u konceptov)
			- t.j. programator si sam musi nadefinovat styles pre to, aby urcil, ze nejaky koncept predstavuje IncompleteCommand
		- neprakticke prevedenie napr. "string" -> "[string]" (t.j. dopisem nejaky character zlava)
			- aj ked existuju sposoby substitucie z nejakeho konceptu na iny, stale mi chyba sposob urobit toto automaticky
			- asi by stacilo, ak by MPS podporoval:
			____ - je abstraktny koncept
			mystring - transformacia na TypeVariable
			
			____ - je abstraktny koncept
			[] - transformacia na TypeList
			
			t.j. mystring- mal by este stale odchytavat, podobne, ako ____, znak [
			[mystring] - po napisani [ pred mystring transformacia na TypeList, pretoze sa na danom mieste mohol vyskytnut a zaroven jeho prvy argument prijima typ TypeVariable, ktoreho je mystring
			- chcelo by to umoznenie niecoho takeho
		- este ku DRY, vadi, ze nemozu zdielat nejake globalne funkcie, ci premenne
			- napr. to, aby som mohol referencovat nejaky REGEXP, ktory udava obmedzenie na nejaky typ (vid priklad s CONID, ci VARID)
		- ide len o navrhy, ktore sa nemusia ukazat ako velmi vhodne, ale zdaju sa, ze by tomuto MPS urcite pomohli pri vytvarani Haskell IDE
		- co mi ale fakt vadi, ze nikde nie je verejne vystavene podrobne API, prip. programatorska dokumentacia
			- t.j. mam napr. metodu (editorContext, node)->boolean { /* ... */ }, ale neviem, co editorContext obsahuje (resp. jak to funguje), coz je trochu zle
		
	- celkovo mi tu vadi nedostatocna dokumentacia pre transformacie - jedna z najdolezitejsich casti MPS, ktora je zle popisana
		- navyse casto updatovana
		- kniha The MPS Language Workbench, ktora je relativne nova, uz ma zastarane informacie, ktore sa neaplikuju
		- mat nedobru dokumentaciu je neakceptovatelne
	- dalsi problem s MPS je v ramci editoru to, ako sa matchuje text
		- idealne by som chcel tu istu transformaciu previest pre range textov, napr. urcit cez regularny vyraz
		- je to zle, pretoze pokial to napisem do "can execute" a nie do "text", tak sa neprevedie automaticky, ale vyhodi mi transformacne menu
		- zda sa, ze sa to da nejak obist, ale bolo by lepsie, keby to nebol text, ktory sa matchuje, ale iba porovnanie, ci dany pattern vyhovuje
		- obchadza sa totiz blbo, typicky je nutne pouzit trie
			h -> e -> y
				   -> l -> l -> o
			  -> i
			...a vratit cely vyraz podla toho, ktorym smerom sa ubera (lubovolny z tych, ktore vyhovuju)
- o com sa treba vyjadrit je, ze s operatorom je to komplikovane
	- projekcny editor je asi lepsi (efektivnejsi), nez bezny pre taketo jazyky, ale je nutne naucit uzivatela, jak ho pouzivat efektivne
	- nejde zachytit transformaciami vsetky mozne upravy, na ktore je clovek v textovych editoroch zvyknuty
		- priklad: 
			- napisane je [(a), (b), (c)] a my chceme zmazat zatvorky medzi a a b aby sme dostali toto: [(ab), (c)]
			- toto normalnym sposobom vobec nejde urobit
		- nehovoriac o extremnom mnozstve prace
	=> je nutne zvolit nejaky styl a vytrenovat uzivatela v tomto duchu
		- napr. ja som zvolil, ze sa musi text pisat postupne, budovat zlava doprava, ako je vacsina uzivatelov zvyknuta
		- teda na navrh jazyka v MPS je urcite nutna expertiza, nejakeho UX dizajnera idealne... rozhodnutia ovplyvnuju dost vela
			- napr. za genialne povazujem standardne komentare, ze sa da predpisat pred akykolvek vyraz //
			- genialne je to, ze ked ten vyraz zmazem, stale mi zachova povodny strom kodu, cize nepresla trasnformacia na text!
				t.j. 
				object.doSomething()		-- predpisem //
				// object.doSomething()		-- zmazem // zlava
				object.doSomething()		-- strom je zachovany
			- chce to cvik
			
- komplikovanejsie veci sa v MPS komplikovane programuju
	- fakt mi tu chybaju triedy
	- programoval som si z isteho dovodu trie (nadvazuje na to, jak sa pouziva cast text v ramci trasnformacii), a narazil som na niekolko problemov
	- sice ide simulovat triedy cez koncepty, je to celkom nevhodne riesenie (minimalne nepekne)
	
- som zistil, ze separatory jednotlivych zoznamov children nefunguju dobre - myslim tym stylovanie
	- priklad:
	ff, gg, (:-:) :: Int
	- nedodrzuje presne riadkovanie, ako som nastavil - vzdy je to inak, niektore medzery su sirsie, niektore uzsie
	- nezavisle od mojho nastavenia - totiz ked nedam ziadne nastavenie, tiez su medzery nekonzistentne
	- zda sa, ze je nutne este pridat stylovanie do jednotlivych children, pokial ide o zoznam abstraktnych konceptov
		- problem je, ze to vnesie naopak problemy inde - napr. punctuation-right: true by znamenalo, ze vsetky children budu blizsie pousunute k tej dvojbodke :: a nic by sa s tym uz nedalo robit
		
- je mozne, ze unarne operatory ako - a ! (to su vlastne jedine) ani nebudem podporovat, lebo chce dalsie upravy gramatiky + transformacie
	- daju sa simulovat cez zadefinovanie funkcii not a minus
	not true = false
	not false = true
	f x = not x
	
	
	
BTW, dalsie chyby v MPSku:
	- zle zdokumentovane Scope, velmi zle
	- toto nefunguje, pokial this je root koncept:
		foreach sibling in this.siblings { 
		  result.addAll(getAllSubNodes(sibling, instance)); 
		}
	- referencie su zle spravene, pokial ide o implementaciu metod nejakeho interface-u, ci rodicovskeho node-u
		- refaktoring mi sposobil, ze sa objavili az kompilacne chyby, ale nic predtym
		- cize tieto referencie su tam urobene zle, vyzera skor na bug