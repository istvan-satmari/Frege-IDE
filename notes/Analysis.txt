TODO
----------------------------------------------
- teraz:
	- umoznit pohodlne editovanie a pouzivanie IDE (t.j. viacere akcie a editory nastavit)
	- vyplnit "description" a "alias" pre koncepty pre jasnejsiu napovedu pri "ctrl + space"
	- stale su veci, ktore neviem, jak sa daju urobit a chyba dostatocne mnzostvo prikladov v MPS na to

- plany na neskor:
	- pozriet sa na operatory; v Haskelli existuje len 1 unarny operator, a to minus (treba opravit)
	- referencie 
		- tyka sa toho aj scoping
		- asi striktne, t.j. ziadne CONID, VARID, a pod.
	- constraints a typesystem
		- kontrola chybne zadanych konstruktov



MODULE (~ Skeleton)
----------------------------------------------
- gramatika:
module ::= 	moduleclause 'where' definitions


- priklad:
module learnyou.chapter05.AFewMoreRecursiveFunctions where

import frege.prelude.Math ()

repeat' x = x : repeat' x
lostNumbers = [ 4, 8, 15, 16, 23, 42 ]

main _ = do	
	println $ packed . quicksort . unpacked $
	

- prevedenie:
	- koncept skeleton s presne definovanymi castami (pre jasnu a prehladnu strukturu kodu)
	- MODULECLAUSE IMPORTS DEFINITIONS MAIN
				

				
MODULECLAUSE (~ Module)
----------------------------------------------
- gramatika:
moduleclause ::= 'module' ((varidkw|CONID) '.')* CONID (VARID+ '(' qvarids ')')*
varidkw ::= VARID|'data'|'type'|'native'|'pure'|'module'|'import'
qvarids ::= qvarop (',' qvarop)*
qvarop ::= (CONID '.' (CONID '.')?)? (VARID|'!'|'?')|SOMEOP
...
[Q] nedava velmi zmysel podla prikladov? necham zjednodusene zatial


- priklady:
module Simple where

module MyModule (MyType, MyClass, myFunc1) where

module MyBigModule (module Data.Set, module Data.Char) where
	import Data.Set
	import Data.Char

module AnotherBigModule (module Data.Set, module AnotherBigModule) where
	import Data.Set
	import Data.Char

	
- prevedenie:
	- 'module' VlastneMenoModulu parts where
	- parts s jednotlivymi castami oddelenymi ciarkami
		- pokial prazdne, zatvorky nezobrazujeme
	- [TODO] zistit, co mozno exportovat a jak
		- striktna referencia, t.j. aby bolo mozne pouzit len konkretne nodes
	- 2 moznosti z abstraktneho: "module QCONID", alebo "QCONID"
		- [TODO] musi byt kvalifikovane meno (v oboch pripadoch)
		- QCONID su CONID oddelene bodkami
	- [TODO] pokial ma koncept obsahovat QCONID, potom musi byt cez akciu transformacie preveditelny
	- [TODO] tu by sa hodila napoveda, napr. "module Data.Set", cize treba referencny koncept
		- referencuje bud to, co sa uz naimportovalo
		- alebo referencuje sam seba ("AnotherBigModule")
	
	[TODO]
	https://www.haskell.org/tutorial/modules.html
	module Tree ( Tree(Leaf,Branch), fringe ) where
	data Tree a = Leaf a | Branch (Tree a) (Tree a) 
	
Note that the name of a type and its constructors have be grouped together, as in Tree(Leaf,Branch). As short-hand, we could also write Tree(..).  Exporting a subset of the constructors is also possible !!!
	
	
	
IMPORTS (~ Import)
----------------------------------------------
- gramatika:
import ::= 'import' modulename1 (VARID? CONID)? importliste
modulename1 ::= ((varidkw|CONID) '.')* CONID
varidkw ::= VARID|'data'|'type'|'native'|'pure'|'module'|'import'
...
priklady opat trochu nezodpovedaju...?
...
importliste ::= 	VARID '(' importspecs ')'
					'(' importspecs? ')'
importspecs ::= importspec (',' importspec)*
importspec ::= importitem (VARID|CONID|SOMEOP)?
importitem ::= 	qvarid
				qconid
				CONID '(' memspecs? ')'		-- napr. "Read(readsPrec, readList)"
				SOMEOP
				'!'
				'?'
memspecs ::= memspec (',' memspec)*
memspec ::= VARID | CONID | SOMEOP


- priklady:
import frege.data.List

import learnyou.chapter14.TakingAWalk ( Tree, Direction, freeTree, **, !! )

import Text.Read (Read())

import Text.Read (Read(readsPrec, readList))

import Text.Read (Lexeme(...))

import Data.Char hiding (isControl, isMark)

import learnyou.chapter07.geometry.Sphere as Sph ()
	

- rozdiely gramatika vs. priklady:
	import qconid (varid? conid)? varid? '(' spec (VARID|CONID|SOMEOP)?, ... ')'
	spec	::= 	qvarid
					qconid
					CONID '(' (VARID | CONID | SOMEOP),  ... ')'
					SOMEOP
					'!'
					'?'	
		
	import qconid (as CONID)? hiding? '(' ((VARID|CONID|SOMEOP) ',')* ')'
	=> alespon nejaka podobnost (zhruba to teda sedi):
	(varid? conid)? 	~ (as? CONID)?
	varid 				~ hiding?
	
	- cast s "spec (VARID|CONID|SOMEOP)?", tak tu zatvorku asi vynecham

	
- prevedenie:
	- import Cesta (as CONID)? hiding? OptionalZatvorky
	- Cesta pozostava z postupnosti: "CONID / VARID" (to ani nie je qconid / qvarid)
		- ziadne referencie tu netreba
		- [TODO] je to skratka qconid, pravdepodobne
	- Pozor, aj podla gramatiky je to tak, ze pokial je "hiding" pritomne, tak musi byt pritomne aj '(' specs ')'
		[TODO] specialne, pokial je pritomne "hiding", tak ta zatvorka importitem-ov musi byt neprazdna, podla gramatiky:
		importliste ::= VARID '(' importspecs ')' | '(' importspecs? ')' -- VARID predstavuje "hiding"	
		- treba vyriesit cez typesystem
	- [TODO] importitem
		- treba doriesit (vsetky) podla upravenej gramatiky nizsie (t.j. chyba qvarid a qconid, operatory, ...)
			qvarid
			qconid -- zahrna aj CONID bez zatvoriek
			CONID '(' memspecs? ')'
			SOMEOP
			'!'
			'?'
			
			memspec ::= VARID | CONID | SOMEOP
			- specialne pre IICMember / memspec, napoveda podla obsahu triedy
			- [TODO] Nejasne, ci pridat: Lexeme(...), t.j. 3 bodky (to asi nie je operator); treba specialny koncept
	- [TODO] Mala by existovat kontextova napoveda k jednotlivym polozkam (treba vyriesit spolu s importom)
	
	

DEFINITIONS
----------------------------------------------
definitions ::= (topdefinition | visibledefinition)+	
topdefinition ::= 	import
					fixity operators
visibledefinition ::= 	'instance' insthead wheredef
						classdef
						datainit wheredef
						typedef
						annotation
						fundef

						
- prevedenie:
	- IMPORTS je samostatna sucast, cize "import" z gramatiky ignorujem
	- DEFINITIONS je abstraktne, od neho dedia:
		- FIXITY
		- CLASS
		- INSTANCE
		- DATA
		- TYPE
		- ANNOTATION
		- FUNCTIONDEFINITION
	- COMMENTS 
		- je vlastne DOCUMENTATION podla formalnej gramatiky a moze byt na viacerych specialnych miestach
		- kazdopadne by malo stacit, pokial umoznime umiestnenie v ramci definitions
		

		
COMMENTS
----------------------------------------------
- prevedenie:
	-- STRING
	{- 
		STRING
		STRING
		...
	-}
	- [TODO] skontrolovat korektnu indentaciu v pripade vnorenych blokovych komentarov
	- [TODO] blokovy komentar moze byt nested, ale asi by som v ramci 1 riadku dal tuto kontrolu:
		- nemoze stat {- osamote (musi byt v tom istom riadku aj takto ukonceny)
		
		

TYPOVANIE (~ Definitions/Types/*)
----------------------------------------------
- gramatika:
rho ::= (simpletype+ '=>')? tau
simpletype ::=  '(' tau (',' tau)* ')'
				'[' tau ']'
				tyvar
				tyname
tyname ::= qconid
tyvar ::= VARID
tau ::= (simpletype+ '->')* simpletype+


- priklady:
[a] -> [b] -> [(a, b)]
(Real a) => [(a, a)]
(Eq a, Num i) => a -> [i] -> Bool
(Integral a) => a -> String
Int -> [a] -> [[a]]
a -> (a -> b) -> b
(Eq k) => k -> Maybe v
(Monoid m) => (a, m) -> (a -> (b, m)) -> (b, m)


- prevedenie:
	- [Q] context je prilis zlozity a nevidel som nikde na to priklad
		- nestaci "class-ovsky"
	
	- [TODO] kontext v zmysle "(simpletype+ '=>')?" by mal byt upraveny na nieco rozumnejsie
		- problematicke, lebo je najprv nutne previes na TypeTuple a odtial sa da dostat k takym konstruktom, ako napr. "(Eq a, Num i) =>"
		- trebars iba "TypeName TypeVariable" oddelene ciarkami
		- zatial v podobe '(' simpletype+ (',' simpletype+)* ')'
	- [TODO] v ramci tohto kontextu sa hodi este referencny koncept pre uz definovany "tyvar"
		- napr. "a -> b -> a" (posledne "a" by malo ponuktnut v ramci napovedy)
	- pozn. simpletype+ (s pluskom) kvoli tymto: napr. "Maybe a"
	- pozn. tyname: qconid - mal by referencovat uz nejaku existujucu triedu (napr. Eq, Num)
		- na druhej strane je nutne umoznit aj vlastnu (import)
	- pozn. tyname:
		- qconid (kvoli importovanym polozkam)
		- [TODO] referencia na existujucu triedu + vyzadovat 1 tyvar (Eq a)
		- [TODO] referencia na existujuce data (Maybe a)
			- potom by sa hodilo automaticky prihodit niekolko tyvar premennych (alebo ich aspon vyzadovat - podla definicie data)
		- [TODO] pozor este na typy (Bool, Integral, Num) a standardne triey (Eq, Shor, Ord)
	- [TODO] tu treba vela akcii:
		- simpletype musi byt rychlo preveditelny na tyvar (po zadani lubovolneho stringu? pozor ale na to, ked chceme nieco referencovat)
		- analogicky simpletype musi byt rychlo preveditelny na tyname
		- tau rychlo preveditelny na simpletype (pokial iba jeden?)
	- pozn. upozornime, ze mame niekolko standardnych typov:
		- Char Bool String Integer (BigInteger v podstate) Float Double Int (32-64 bitovy)
		- spadaju pod "tyname"; mozno asi vytvorit vlastne koncepty pre kazdeho z nich (su to standardne typy; ostatne sa daju vytvorit len pomocou Data)...?
	- pozn. taktiez upozornime, ze mame niekolko standardnych tried:
		- Num (superclass to Int, Integer, Float, Double)
		- Integral (superclass to Int, Integer)
		- Floating (superclass to Float, Double)
		- RealFloat
		- Potom dalsie "exotickejsie": 
			- Eq Ord Show
		- Uvedme priklad:
			f :: (Num a) => a -> a -> Bool
			- pri anotacii funkcie Num je trieda, ostatne su typy (trieda ani inde nemoze stat)
			- toto asi treba overit po formalnej stranke

			
			
TYPE (~ Type)
----------------------------------------------
- gramatika:
typedef ::= 'type' CONID tyvar* '=' rho


- priklady:
type Breadcrumbs = [String]

type Breadcrumbs a = [Crumb a]

type ListZipper a = ([a], [a])


- prevedenie:
	- [TODO] v ramci rho by sa hodilo nejak injektovat tie tyvars, ktore boli deklarovane uz za CONID
		- ako kontextovu napovedu, napr.:
		type Breadcrumbs a = [Crumb <<tu by malo vediet ponuknut "a">>]	
	- [TODO] zaroven by asi mali mat navzajom odlisne meno, ale to cez typesystem / constraint
	- [TODO] zaroven treba potom odinadial vediet referencovat tento "type"
		- ako priklad: "CONID" musi byt obaleny specialnym konceptom "TYPEDEFNAME", ktory sa bude dat referencovat
		- nemozeme referencovat vsetky CONID-y...
	
	

FIXITY (~ Fixity)
----------------------------------------------
- gramatika:
fixity operators
fixity ::= ('infix'|'infixl'|'infixr') INTCONST
operators ::= (SOMEOP | VARID | '-')+


- priklady:
infixl 7 `-:`

infixl 8 ‘myplus‘


- prevedenie:
	- 3 varianty podla zacinajuceho slova
		- [TODO] jak sa napise "infix", vytvori sa "fixity" koncept, ale bude treba vediet rychlo prevadzat medzi infix / infixl / infixr (cez akcie, asi)
	- [TODO] nezabudnut na znaky "`", ktore z nejakeho dovodu nie su v gramatike popisane
	- [TODO] operatory - v podstate lubovolne poskladanie specialnych symbolov, s pravidlami:
		- pozn. tu by sa operator nemal referencovat, tu sa zadava vlastny operator
		- nesmu pouzivat rezervovane symboly:
		..  :  ::  =  \  |  <-  ->  @  ˜  =>
		- mozno skladat z tychto symbolov:
		#  $  %  &  *  +  .  /  <  =  >  ?  @  \  ^  |  -  ~
		
		- podrobnejsie:
		http://stackoverflow.com/questions/10548170/what-characters-are-permitted-for-haskell-operators
		
		asciiSymbol  ->   ! # $ % & * + . / < = > ? @ \ ^ | - ~
		symbol     ->   asciiSymbol | unicodeSymbol (any Unicode symbol or punctuation, t.j. nie bezne pismena), okrem: ( ) , ; [ ] ` { }  _ : " '
			- budem podporovat len asciiSymbol
			
		reservedop -> ..  :  ::  =  \  |  <-  ->  @  ~  =>
		
		varsym     -> symbol (symbol | :)*    	-- pricom sa ale nesmie naskladat na "reservedop" a ani nesmie mat formu ---------- atd. ("dashes")
		consym     -> : (symbol | :)*			-- pricom sa ale nesmie naskladat na "reservedop"

        An operator symbol starting with a colon ":" is a constructor.
        An operator symbol starting with any other character is an ordinary identifier.
		
		Konstruktorove operatory nas ale nemusia zaujimat, lebo nasledujuci priklad:
		data Rose a = a :> [Rose a] deriving Show
		main = print $ 7 :> [1 :> [], 2 :> [], 3 :> [0 :> []]]
		vo Frege neprejde a naopak tento priklad:
		x :- y = x*y*2
		main = print $ 7 :- 2
		neprejde v Haskelli, ale zato vo Frege ano.
		
		Celkovo tak:
		symbol ::= ! # $ % & * + . / < = > ? @ \ ^ | - ~ :
		operator ::= symbol*
		pricom sa nesmie naskladat na:
		reservedop -> ..  :  ::  =  \  |  <-  ->  @  ~  =>
		[TODO] skontrolovat cez constraint / typesystem, ci sa operator nenaskladal na nepovolenu sekvenciu
		


ANNOTATION (~ Annotation)
----------------------------------------------
- gramatika:
annotation ::= annoitems '::' rho
annoitems ::= annoitem (',' annoitem)*
annoitem ::=	VARID
				'(' SOMEOP ')'
				'(' '-' ')'
				'(' '?' ')'
				'(' '!' ')'
								
				
- priklady:
zip :: [a] -> [b] -> [(a, b)]

(-:) :: a -> (a -> b) -> b

(<), (<=), (>=), (>)  :: a -> a -> Bool

elem :: (Eq a, Num i) => a -> [i] -> Bool

map :: (a -> b) -> [a] -> [b]


- prevedenie:
	- vychadza z typovania
	- pozor na to, ze mozno definovat viacere naraz a ze mozno anotovat aj operatory
	- nazvy anotovanych poloziek (vid fundef pre dalsie detaily)
	- [TODO] jednotlive anotovane polozky treba nejak zlepsit...
		- momentalne chyba !, ?, - (neviem, ci vobec budem pridavat?)
		- operator je nedokonceny
	
	
	
FUNCTIONDEFINITION (~ FunctionDefinition)
----------------------------------------------
- gramatika:
fundef ::= 	binex '=' expr wherepart
			binex ('|' gquals '=' expr)+ wherepart

gquals ::= gqual (',' gqual)*
gqual ::= expr
- guardy oddelene ciarkami


- priklady:
f x = 2 * x

f 0 = 1

replicate n x
    | n <= 0    = []
    | otherwise = x : replicate' (n - 1) x
	
(a, b, c) = (1, 2, 3)

(x:y:z:_) = [1,2,3,4,5,6]

a `myop` b = a + b

x -: f = f x

surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)


- prevedenie:
	- dava vacsi zmysel zlucit viacere patterny tej istej funkcie do jednej skupiny (inak problem pri kompilacii)
		- [TODO] skupina definicii ale musi nieco zdielat, v tomto pripade asi "binex"
			=> zmena v jednom patterne spravi zmenu v ostatnych
		- [Q] mozno ako optional hodit anotaciu? (deklaraciu funkcie)
	- [TODO] cez typesystem okontrolovat zhodnost patternov, t.j. nesmie nastat toto:
		f a b c = 1
		f i j k = 2
	- [Q] zatial som sa nestretol s viacerymi podmienkami v ramci jedneho guardu, treba preverit (vid "gquals ::= gqual (',' gqual)*"; t.j. guardy oddelene ciarkami)
	- [TODO] pozor na slovo "otherwise" pri guard-och, malo by ho vediet napovedat (t.j. urobit samostatny koncept)
	- patternovanie:
		- zdroje nasledujucich informacii:
			- https://www.haskell.org/tutorial/patterns.html
			- https://en.wikibooks.org/wiki/Haskell/Pattern_matching
		- v gramatike je pattern urceny len cez "binex", ale uz pri kompilacii niektore veci vyhodia chybu, napr.:
			f (x+1) = 0
			f [1..10] = 0
			f [x | x <- [1..10]] = 0
			f x x = 3*x
		- podla oficialnej dokumentacie, plati nasledujuce:
			- nesting of patterns is permitted (to arbitrary depth)
			- formal parameters (variables) are also patterns that never fail to match a value
			=> tie iste premenne sa preto nemozu vyskytovat viackrat, nez raz, v danom patterne (wildcard "_" moze)
		- tieto priklady zase prejdu:
			f ([],  'b',  (1,   2.0),   "hi",   True) = False
			f [] = 0
			f [1, 2, 3] = 0
			f [x, y] = x+y
			f (x : xs) = 1
			g (1, [2, 3]) = 1
			g (x, _) = x
			f x y = 2*x
			a `myop` b = a + b
			surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)
			(a, b, c) = (1, 2, 3)
			(x:y:z:_) = [1,2,3,4,5,6]
			(a, b, c):[d] = [(1, 2, 3), (4, 5, 6)]
			ff (a, b) (c, d) = 0
			[1, gg] = [1, 7]
		- ale toto nie:
			(f x, g y, h z) = (2*x, 3*y, 4*z)
			(f1, f2) (f3, f4) = (1, 2) (3, 4)
			(f1, f2) (f3, f4) = (1, 2, 3, 4)
			[7] = [10]
			[7] = [7]
			f 1:2:3:[] = 0			-- chybaju zatvorky, cize "f (1:2:3:[]) = 0" by uz preslo
			f (1:(2, 3):4:[]) = 0	-- nie je mozne mixovanie v ramci daneho zoznamu, inymi slovami ani toto neprejde: "f = [1, (2,3), 3]"; mozno skontrolovat jedine cez typesystem (jednotlive prvky mozu byt dost komplikovane)
			f (1:2:3) = 0			-- zoznam musi byt zakonceny objektom typu "zoznam"
			f (1:[2]:[3]) = 0		-- nie je mozne mat prvky rozlicneho typu; a:b:c:d - az "d" je typu "zoznam", "b", "c" su stale bezne prvky; ale! "(a:b):c", tak jak "b" tak "c" su zoznamy! zatvorky robia velky rozdiel!
		- toto prejde, ale vyhodi runtime exception pri pokuse pouzit:
			(f1, f2, f3) = (1+f1, 1+f2, 1+f3)
			[1, f] = [2, 3]
		- dalsie pravidla:
			- funkcie v pattern matchingu nie su povolene, okrem konstruktorov z "data"
			- zoznamy su vynimkou kvoli tomu, ze plati akoby toto: data [a] = [] | a : [a] (cize sa tiez chova ako "data")
				=> prazdny zoznam [] - je konstruktor
				=> : funkcia - je konstruktor
				=> f (_:_:_:xs) = xs, tak trivialne musi prejst
				=> [x, y, z] je len syntactic sugar pre x:y:z:[], cize stale povolene
			- analogicky plati pre tuples: f (x, y, z) = x + y + z
		- pravidla pre zoznamy:
			f1 ((1:[2]):[[3]]) = 0	-- prijima [[1,2],[3]]
			f2 (1:(2:[3])) = 0		-- prijima [1,2,3]
			f3 ((1:2):[3]) = 0		-- neprejde
			=> pokial je (x1:x2:...:xn) uzatvorkovane, uz to musi byt zoznam
			=> potom vyhovuju tieto: 
				x:(y:ys) 		-- prepend, pripad f2
				(x:xs):[ys] 	-- append, ys musi byt zoznam, pripad f1
			- cize ked sa na vrchu objavi ':', mali by sa vytvorit zatvorky
		- celkovo mozno uvazit zhruba toto:
			- evidentne funnkcia ako nieco s argumentami moze byt definovana len standardne, t.j. meno musi byt na zaciatku a potom argumenty, inak definicia typu (a,b,c) = (1,2,3) je skor definicia unarnych funkcii
			- predpokladam nieco takehoto druhu:
				fundefhead ::= name args? | arg | arg OPERATOR arg
				args = (arg ' ')* arg
				arg ::= pExpression
				pExpression ::= pTuple | pList | pConstructor | pLiteral | pVariable
				pVariable ::= _ | varid
				pLiteral ::= IntValue | CharValue | StringValue | BoolValue | ...
				pConstructor ::= '(' CONID args ')'
				pList ::= '(' listColonItems ':' pList ')' | '[' pExpressions? ']' | pVariable
				listColonItems ::= (pExpression ':')* pExpression
				pExpressions ::= (pExpression ',')* pExpression
				pTuple ::= '(' pExpressions ')'
				- nie uplne dotiahnute veci:
				[TODO] nejasny nazov funkcie; zatial nastaveny na VARID
				[TODO] neujasnene, co to je operator (vid PatternOperator)
				[TODO] literaly zatial vobec nie su (treba zneuzit koncept z expression nejako)
				[TODO] ani pConstructor nie je jasny zatial
				[TODO] bude treba akcie na prevadzanie z jedneho konceptu rychlo na druhy; o referencovani nehovoriac, s tym tam bude celkom dost prace
			- vsetky priklady, co maju prejst, prejdu, ale prejdu, zial, aj tieto:
				- tieto sa tazko deteguju; vyhadzuju az run-time error:
					(f1, f2, f3) = (1+f1, 1+f2, 1+f3)
					[1, f] = [2, 3]
				- toto treba overit cez typesystem:
					[TODO]	f x x = 3*x				-- rovnake argumenty nalavo
					[TODO]	[7] = [10]				-- nalavo nie je ziadna pramenna
					[TODO]	f (1:(2, 3):4:[]) = 0	-- nie je mozne mixovanie v ramci daneho zoznamu; cize cez typesystem
							blargh2 (1:[2]:[3]) = 0	-- opat ide len o mixovanie rozlicnych prvkov
					[TODO?] - jedine cez typesystem prinutit, aby "pVariable" nebolo meno existujucej funkcie:
							k = 1
							h :: Int -> Bool
							h k = True
							h _ = False
					[TODO] - pozor na redefinition; napr.:
					(a:b:c:_) = [1,2,3,4,5,6,7]
					a = 10			
	- [TODO] nazvy funkcii nesmu byt jednym z rezervovanych slov:
		- case, class, data, default, deriving, do, else, foreign, if, import, in, infix, infixl, infixr, instance, let, module, newtype, of, then, type, where, _ (pokial je osamote)
		- tyka sa aj annotation
	- [Q] referencovat name?
		- t.j. pokial uz funkcia bola anotovana, tak mozno referencovat
		- mozno referencovat operatory definovane v ramci fixity
	- [TODO] nezabudnut este na indentaciu a nutnost vediet vytvarat prazdne riadky
	- guard-i podla specifikacie su:
		- [TODO] bud boolean expresions, cize treba okontrolovat cez typesystem
		- [Q] alebo mozu byt aj klasickym patternom, v tom pripade mozno pouzivat nasledujucu syntax:	
			strangeOperation :: [Int] -> Ordering
			strangeOperation xs | 7  <- sum xs, n <- length xs, n >= 5, n <= 20 = EQ
								| 1  <- sum xs, 18 <- length xs, r <- nub xs `compare` [1,2,3], r /= EQ = r
								| otherwise = [3,1,2] `compare` xs

	
		

WHEREPART (~ WherePart)
----------------------------------------------
- gramatika:
wherepart ::= 'where' letdefs?
letdefs ::= (annotation|fundef) ('\n' (annotation|fundef))*
- t.j. bud su tam definicie funkcii, alebo aj deklaracie funkcii


- priklady:
describeList xs = "The list is " ++ what xs ++ y
    where what []  = "empty"
          what [x] = "a singleton list"
          what xs  = "a longer list"
		  y        = "another string"
		  
		  
f = giveme 100
     where giveme x = if isbig x then x else 0
           isbig x = x > 0

		  
bmiTell weight height
    | bmi <= skinny = "You're underweight, you emo, you!"
    where (skinny, normal, fat) = (18.5, 25.0, 30.0)

	
- prevedenie:
	- [TODO] editor je urcite zatial nakonfigurovany nespravne
	- [TODO] koncepty musia byt rychlo preveditelne (t.j. annotation <-> FDAnnotation, atd.)
	- [TODO] tu musi byt kontextova napoveda; musi byt akoby zuzena na sucasny scope
	

	
WHEREDEF
----------------------------------------------
- gramatika:
wheredef ::= ('where' localdefs )?
localdefs ::= localdef ('\n' localdef)*
localdef ::= 	annotation
				fundef


- priklady:
class YesNo a where
    yesno :: a -> Bool
	
instance YesNo Int where
    yesno 0 = false
    yesno _ = true
	
...


- prevedenie:
	- v ramci localdef moze byt bud anotacia (deklaracia funkcie) alebo definicia funkcie
	- identicke WherePart, avsak byva v spojeni s class / instance; bude to teda takto: 
		- v ramci class / instance bude prvy riadok prisposobeny danej definicii + slovo "where" na konci
		- zvysok bude podla WherePart casti
	- [TODO] aj tu treba spravne poriesit referencovanie

	
	
EXPRESSION (~ Expression)
----------------------------------------------
- gramatika:
expr ::= binex ('::' rho)?
binex ::= (binex (SOMEOP|'-'))* '-'? topex


- priklady:
f n = n `div` 2


- prevedenie:
	- EXPRESSION je bud:
		- prave 1 TOPEXPRESSION (moze mat unarne minus pred sebou)
			- treba davat pozor na unarnu negaciu (! operator) a dalsie unarne operatory => precesat gramatiku este raz na toto
		- alebo BINARYEXPRESSION
			- ma lavu a pravu cast (obe su EXPRESSION)
			- medzi nimi je operator: (SOMEOP | '-')
		- vo vacsine jazykov je presny pocet rozdeleni BINARYEXPRESSION, napr. *, +, /, ... (kazda vlastny koncept)
			- v Haskelli su operatory arbitrarne, cize by sa hodilo cez akciu pri pisani akehokolvek symbolu automaticky vytvorit BINARYEXPRESSION a dosadit za operator napisany text
	- sice dany priklad by mal prechadzat cez TOPEXPRESSION a nie cez EXPRESSION, pretoze `div` nespada pod SOMEOP, aj tak to tu spravime takto
		- je to logickejsie, kedze de facto ide o operator
		- cize semanticka analyza na to, ci skutocne ide o binarnu funkciu, sa musi odohrat tu
	=> rozhodnutie urobit takto - vlastna gramatika:
		expr ::= exprPart ('::' rho)?
		exprPart ::= topex | binex | unopexpr
		binex ::= exprPart SOMEOP exprPart
		unopexpr ::= '(' SOMEOP exprPart ')'	
	- [TODO] operator ako koncept nie je zatial definovany
	- [TODO] vymysliet plynule prepinanie a volbu medzi jednotlivymi druhmi expression; pravdepodobne cez viacere akcie substitucii
	- [TODO] zistit, jak je to presne s unarnymi operatormi; skutocne mozu byt lubovolne? nie je to nahodou iba minus '-'?
	- [TODO] v zavislosti od predchadzajuceho bodu test, ci pouzity operator je skutocne binarny alebo unarny (typesystem)
	- [TODO] operator by teroeticky mohlo napovedat z dostupnych
			


TOPEXPRESSION (~ TopExpression)
----------------------------------------------	
- gramatika:
topex ::= 	'if' expr 'then' expr 'else' expr
			'let' letdefs 'in' expr
			'case' expr 'of' calts
			lambda
			(('!'|'?')* term)+

- priklady:
f 1 2 3

(+) 1 a

(,,) (x > 0) (x % 2 == 0) (x % 3 == 0)

map (*) [0..]

(\x -> \y -> \z -> x + y + z) a b c

multThree x y z = x * y * z
multTwoWithNine = multThree 9

-- aplikacia funkcie s dvomi argumentami; druhy argument je term - uzatvorkovany vyraz, pricom v ramci vyrazu ide opat o aplikaciu funkcie s jednym argumentom (tu uz literalom - cislo "3")
filter ((==) 3) [ 1, 2, 3, 4, 5 ]

-- pozor, tu uz to neplati, (++ str) tvori vyraz, ale "++" nie je aplikacia funkcie, ale operator
onLeft str = (++ str)

-- bez zatvoriek nefunguje, ale su povolene vsetky nasledujuce varianty; cize z gramatickeho hladiska nespada pod BINARYEXPRESSION, ale "specialny variant termu"?
onRight str = (str ++)
onRight str = (++ str)
onRighta str = (++ str ++ "a")

createCircle r = Circle (Point 0 0) r


- prevedenie:
	- pozor na "(('!'|'?')* term)+", mozno iba "term+"? (predpokladam, ze ide o unarne operatory a tie boli vyriesene uz skor)
	- [TODO] akcie substituovania termov, napr. pri napisani "7" => automaticky literal
	- term+ mozno nahradit takto:
		- samostnatny term: list, tuple, literaly, ...
		- aplikacie funkcii
			- klasicka aplikacia funkcie
			f [1, 2, 3]
			
			- aplikacia operatorov ako funkcii (avsak ine, ako BinEx, kde je operator v strede)
			(+) 1 a
			map (*) [0..]
			filter ((==) 3) [ 1, 2, 3, 4, 5 ]
			
			- currying
			f x y = x + y
			g = f 0
			filter ((==) 3) [ 1, 2, 3, 4, 5 ]
			
			- pozor na specialny typ "currying-u":
				f x = (x+)
				g y = (f 1) y		- (f 1) vrati funkciu, ktoru ihned aplikujeme na "y"
				
				f x = (-x)
				g y = y (f 1)		- prelozi, ale spusta sa napr. cez "g (7 +)" (t.j. y je funkcia prijimajuca 1 celociselny argument)
					
				f x = (-x)
				g y = y + (f 1)		- ok, (f 1) vrati cislo

				f x = (x+1+)		- neprejde
				g y = (f 1) y
				
				f x = ((x+1)+)		- prelozi
				g y = (f 1) y
				
				f x = (++x)
				g y = (f "hello") y	- prejde pre 'g "str"'
			
			- pozor na aplikacie konstruktorov:
			(,,) (x > 0) (x % 2 == 0) (x % 3 == 0)
		
		- aplikacia lambda funkcii
			- klasicka aplikacia lambda funkcie:
			(\x -> \y -> \z -> x + y + z) a b c
			
			- zaroven currying, prip. navratenie len lambdy
			(\x -> \y -> \z -> x + y + z) a b
		
		- konstruktory a argumenty
			(Rational x1 y1) +. (Rational x2 y2) = (x1 * y2 + x2 * y1) % (y1 * y2)
		
			data Point = Point Int Int
			data Circle = Circle Point Int

			f = Circle (Point (1+2) (2+3::Int)) 7
			g = Point 1 2
			
		
		- Celkovo tak mozno zhrnut nasledovne:
		term+_improvement ::= '(' name arg (' ' arg)* ')'
			- name: 
				- qvarid, pokial nazov funkcie
					- [TODO] qvarid, nie varid
				- '(' operator ')', pokial operator ako funkcia
				- '(' lambda ')', pokial aplikujeme ad-hoc lambda funkciu
				- qconid, pokial nazov konstruktoru
					- [TODO] qconid, nie conid
				
				nejasne, preco aj tieto su podporovane (a jak presne zapadaju do ostatnej gramatiky):
				'(' '(' expression ')' operator ')' arg*
				'(' operator '(' expression ')' ')' arg*
				[TODO] toto zatial nie je podporovane a ani neviem, ci bude podporovane
				
			- arg: 
				- expression 
					- ich pocet moze byt <= poctu argumentov definovanych pre danu aplikovanu funkciu, pokial ide o aplikaciu funkcie (pozor na to, ze moze byt obcas aj nekonecny)
					- pokial ide o konstruktor (z "data"), potom je pocet argumentov striktny
			- zatvorky nie su nutne, ale hodia sa a z gramatiky nie je jasne, kde presne maju byt
		
		- [Q] gramatika mozno nie je uplne takto spravna
		- [TODO] meno funkcie by sa malo napovedat (referencovat)
		- [TODO] pocet parametrov (nesmie presiahnut, prip. musi byt striktny)
		- [TODO] zabezpecit, ze je pouzity korektny typ (aplikacia funkcie; prijima argumenty korektneho typu? => typesystem)
		
		
		
TERM (~ Term)
----------------------------------------------
- gramatika:
term ::= 	QCONID
			QVARID
			'_'
			literal
			
			'(' ')'
			'(' SOMEOP ')'
			'(' expr (',' expr)* ')'
			
			'[' ']'
			'[' expr (',' expr)* ']'
			'[' expr (',' expr)* '..' ']'
			'[' expr (',' expr)* '..' expr ']'
			listcomprehension

QCONID ::= (CONID '.')? (CONID '.')? CONID
QVARID ::= 	CONID '.' (CONID '.')? (VARID | '!' | '?') 
			VARID	

			
- priklady:
	- zatvorky / tuples:
		(toList "Steve Buscemi")
	
	- zoznamy:
		[ 4, 8, 15, 16, 23, 42 ]
		
		[ [ 5, 4, 5, 4, 4 ], [ 1, 2, 3 ], [ 3, 5, 4, 3 ], [], [ 2 ], [ 2, 2 ] ]
	
		[ 'K' .. 'Z' ]
		
	- rozlicne:
		- ide vlastne o BINARYEXPRESSION, medzi nimi operator :, potom nalavo a napravo su termy
		1 : [ 2, 3, 4, 5 ]	
	
	
- prevedenie:
	- po novom, aplikacia funkcie, "data" konstrukty a pod. nie su sucastou tohto a spadaju pod samostatne koncepty
	- mozno prerozdelit term na vacsie celky:
		references ::= QCONID | QVARID
		underscore ::= '_'
		literal ::= literal
		tuple ::= '(' expr (',' expr)+ ')'
		expression ::= '(' expr ')'
		list ::= '[' ']' | '[' expr (',' expr)* ']' | '[' expr (',' expr)* '..' ']' | '[' expr (',' expr)* '..' expr ']' | list_comprehension
	- [Q] tieto zatial nie su podporovane:
		'(' ')'
		'(' SOMEOP ')'	
	- [Q] tento druh nie z QVARID zatial nie je podporovany:
		QVARID ::= 	CONID '.' (CONID '.')? ('!' | '?') 
	- [TODO] referencovanie QCONID a QVARID v zavislosti od scope-u
		- asi tazke zabezpecit, lebo to bude chciet referencovat len v ramci urciteho scope, napr.:
			f x = 2 * x		-- x je referencovatelne
			f y = 2 * y		-- tu je referencovatelne len y
		- musia byt referencovatelne aj uz definovane ine funkcie
		- a potom mame zopar standardnych funkcii, napr.:
			- fst a, snd a (tuples)
	- [TODO] term "_" sa nemoze vyskytovat hocikde
	- [TODO] pozor na zaporne cisla a medzery v pripade zoznamov (dat pozor pri generacii kodu):
		[-110..-100] 	-– syntax error
		[-110.. -100] 	-- ok



LIST COMPREHENSION
----------------------------------------------		
- gramatika:
listcomprehension ::= '[' expr '|' lcquals ']'
lcquals ::= lcqual (',' lcqual)*
lcqual ::= 	expr
			expr '<-' expr
			'let' letdefs


- priklady:
	[ [ x, y, z] | x <- [ 1, 2 ], y <- [ 3, 4 ], z <- [ 5, 6 ] ]
	
	[ a + b | (a, b) <- xs ]
	
	[ c | c <- str, c `elem` ['A'..'Z'] ]
	
	[(a, z) | a <- [1..3], b <- [1..3], let z = min a b]
	
	
- prevedenie:
	- priradenie, ako napr. "expr '<-' expr", pravdepodobne bude pattern, preto zmenene
	- [Q] 'let' letdefs len ako jeden letdef, lebo to bude asi neprehladne ich pisat viacero do jedneho riadku
	- [TODO] pre koncept guardu treba overit, ze skutocne vracia typ boolean
	- [TODO] pravdepodobne bude treba akcie transformacie pre prechody medzi jednotlivymi definiciami zoznamov
	- [TODO] pozor na referencovatelnost a scope
		[x | x <- [1..10] ]
		- tu si vytvarame novu premennu x, ktoru potom chceme vediet referencovat
	

	
LITERAL
----------------------------------------------	
- gramatika:
literal ::= 'true' | 'false'
			CHARCONST
			STRINGCONST 
			INTCONST | BIGINTCONST
			DOUBLECONST 
			REGEXP
			
			
- priklady:
	- CHARCONST (char)
		'a', ' ', '\n', '\&', '\DEL', '\CAN', '\ACK', '\0032101', '\0o1770', '\0x8A9E4001'
		- pozri: http://book.realworldhaskell.org/read/characters-strings-and-escaping-rules.html
		- boli implementovate len 1 znakove escapes, UNICODE escape zatial nie je podporovany
	
	- STRINGCONST (string)
	"hello, \n, world"
	"viacriadkovy\
	string\
	takto"

	- INTCONST (integer)
	0098400984065406840680465430210301 (moze zacinat nulou)
	0o00710320007020101 (octal)
	0x000AFEE0D9AA1DD003300211110 (hexadecimal)
	
	- DOUBLECONST (float)
	 009840098406540684068046.5430210301E+10 (iba decimalny zapis)
	 1046.1E-10
	 
			
- prevedenie:
	- [TODO] jak je to s unarnym operatorom minus pred integer a double? mozno zneuzit uz ten z expressions?
	- [TODO] akcie na substituovatelnost, typicky expression -> literal, napr. po zacati pisania "7", "mystring", ... => substituovat za prislusny literal
	- [Q] mnohe zrejme vynecham (REGEXP, INTCONST / BIGINTCONST - staci len INTCONST), a zrejme aj druhy zapisov (napr. octalovy, hexadecimalny zapis a pod.)
		- podpora len jednoducheho char-u, bez escape
	- [Q] podporovat viacriadkove stringy?
	- [Q] podporujem len BIGINTCONST, ma zmysel podporovat aj zvlast INTCONST?
	- [Q] s typom REGEXP som sa este nestretol, tak ho zatial vynechavam
		
		

CASE (~ Case)
----------------------------------------------
- gramatika:
topex ::= 	'case' expr 'of' calts
			... dalsie moznosti pre topex ...

calts ::= calt ('\n' calt)* 
calt ::= 	expr '->' expr wherepart
			expr ('|' gquals '=' expr)+ wherepart
- sice na zaciatku "calt" je udane "expr", v skutocnosti ide aj tak iba o pattern


- priklady:
head xs = case xs of
    [] -> error "No head for empty lists!"
    (x : _) -> x

routine = case landLeft 1 (0, 0) of
        Nothing    -> Nothing
        Just pole1 -> case landRight 4 pole1 of
			Nothing    -> Nothing
			Just pole2 -> landLeft 1 pole3
				
strcmp s1 s2 = 
	case (s1, s2) of
		([], []) -> True
		(s1:ss1, s2:ss2)
			| toUpper s1 == toUpper s2 -> strcmp ss1 ss2
			| otherwise -> False
		_ -> False 
				
f x = let a = w x in case () of 
			_ | cond1 x   -> a
			  | cond2 x   -> g a
			  | otherwise -> f (h x a)
			  

- prevedenie:
	- [TODO] unita "()" reprezentuje "no useful information"; treba napomoct v typesystem toto pochopit
	- [TODO] editor upravit
	- [TODO] napovedy (ctrl + space), jak obvykle
	

	
IF-THEN-ELSE (~ IfThenElse)
----------------------------------------------
- gramatika:
topex ::= 	'if' expr 'then' expr 'else' expr
			... dalsie moznosti pre topex ...
	

- priklady:	
yesnoIf x yesResult noResult = if x > 100 then yesResult else noResult
		


LAMBDA (~ Lambda)
----------------------------------------------
- gramatika:
lambda ::= '\' term+ lambdabody
lambdabody ::= lambda | '->' expr


- priklady:
addThree = \x -> \y -> \z -> x + y + z

sumThree a b c = (\x -> \y -> \z -> x + y + z) a b c

flip f = \x \y -> f y x

f x = (\z y -> z+y) x x	

f x = (\(a,b,c) -> a+2*b+3*c) (x,x,x)


- prevedenie:
	- [Q] v ramci gramatiky je "term+", ale pravdepodobne sa staci obmedzit iba na "\x \y -> ...", a toto nepodporovat: "\x y -> ..." - prinutime cistejsi kod (?)
		- ak nie, potom treba PatternArgument dat na "1..n"
	- [Q] zaroven - nemal by to byt jednoduchy pattern a nie term? zatial som tak skutocne nastavil (na pattern)
	- BTW, toto neprejde: f = (\ -> 1), cize aspon 1 term je naozaj nutny
	- [TODO] potrebne akcie substitucie expr a lambda za lambdaPart
	- [TODO] term-y v "'\' term+" nic nereferencuju, lambdabody ale uz musi vediet referencovat termy udane nalavo v "'\' term+"


LET (~ Let)
----------------------------------------------	
- gramatika:
letdefinition ::= 'let' letdefs 'in' expr
letdefs ::= (annotation|fundef) ('\n' (annotation|fundef))*


- priklady:
shortLinesOnly input =
    let allLines = lines input
        shortLines = filter (\line -> length line < 10) allLines
        result = unlines shortLines
    in  result
	
mylist = [let square x = x * x in (square 5, square 3, square 2)]
	
cylinder r h = let sideArea = 2 * pi * r * h 
				   topArea = pi * r ^ 2
			   in  sideArea + 2 * topArea

f x = let a = x - 1 in case () of 
		_ | x > 0     -> a
		  | x == 0    -> g a
		  | otherwise -> h a
				
firstThree str = let (a:b:c:_) = str
				 in "Initial three characters are: " ++ show a ++ ", " ++ show b ++ ", " ++ show c

f = (let (a, b, c) = (1, 2, 3) in a + b + c) * 100


- prevedenie:
	- [TODO] editor je urcite zle zatial
	- [TODO] treba davat pozor na referencovanie, t.j. raz definovana funkcia musi byt refrencovatelna neskor (obzvlast v "in" casti)
		- pozor na scope / referencovanie, oproti where:
			- pokial su pouziti guard-i, "the scope of the where clause extends over all guards; the scope of a let expression is only the current function clause (and guard)"



DATA (~ Data)
----------------------------------------------
- gramatika:
datainit ::= 'data' CONID tyvar* '=' dalts wheredef
dalts ::= dalt ('|' dalt)*
dalt ::= CONID simpletype*


- priklady:
data Point = Point Float Float

data Cool a = Something Float Float | Hooray a a

data Shape = Line Point Point | Rectangle Point Point

data FSItem = File Name Data | Folder Name [FSItem]

data Opx a b c = Sumx a | Zerox


- prevedenie:
	- wheredef mozno netreba, v prikladoch nie je velmi bezny
	- [TODO] cez akcie plynule vytvorenie skryteho "simpletype*" v ramci dalts
		- "Nothing | Just_|"
	- [TODO] referencovanie musi byt kontextualne, ale spada pod "simpletype"
		- referencovat mozno uz existujuce ine data
		- pripadne data deklarovane nalavo od konstruktorov
		- pripade tyvar deklarovany nalavo od konstruktorov
		- pripadne typ (Float, Int, ...)
	- [TODO] semantickou analyzou:
		- "data Opx a b c", potom "a", "b", "c" musia byt rozneho nazvu
		- pokial sa budem nudit, tak mozno urcit, ze "b" a "c" su redundantne v tomto: "data Opx a b c = Sumx a | Zerox"
		
		

CLASS (~ Class)
----------------------------------------------
- gramatika:
classdef ::= 'class' (ccontext '=>')? CONID tyvar wheredef
ccontext ::= qconid tyvar (',' qconid tyvar)*
- wheredef je vynechany a namiesto toho zrecyklovany "LetDefinitions" koncept


- priklady:
class YesNo a where
    yesno :: a -> Bool
	
class Eq a where
    (/=) :: a -> a -> Bool
    x /= y = not (x == y)	
	
class (Eq a) => Ord a where
  (<), (<=), (>=), (>)  :: a -> a -> Bool
  x > y               	= not (x <= y)

class Functor f where
	fmap :: (a -> b) -> f a -> f b
	
instance Functor [] where
	fmap = map
	

- prevedenie:
	- [TODO] context musi byt QCONID, nie CONID
	- [TODO] v ramci "ccontext" treba vediet referencovat uz existujuce triedy
		- prip. nemusia, pokial su naimportovane...?
	- az na bizarnost s prikladom "Functor" by nemalo byt komplikovane (opat ide o referencovatelnost z vnutra "wheredef", cize treba nejako injektovat?)
	- pozor na zhlukovu anotaciu (deklaraciu funkcie)
	
	
	
INSTANCE (~ Instance)
----------------------------------------------	
- gramatika:
instancedef ::= 'instance' (icontext '=>')? qconid simpletype wheredef
icontext ::= '(' qconid simpletype (',' qconid simpletype)* ')'

	
- priklady:
instance YesNo Int where
    yesno 0 = false
    yesno _ = true
	
instance YesNo [a] where
    yesno [] = false
    yesno _  = true

instance YesNo Bool where
    yesno = id
	
instance (Eq m) => Eq (Maybe m) where
    Just x  == Just y  = x == y
    Nothing == Nothing = true

instance Functor (HM.HashMap k) where
    fmap = HM.mapValues	
	

- prevedenie:
	- [TODO] name by malo byt QCONID a nie CONID, ako je teraz
	- [TODO] zaroven meno by malo byt referencovane; robi sa predsa instancia nejakej konkretnej triedy
	- [Q] "id" asi nebudem podporovat (treti priklad)
	- v ramci "qconid", ked sa zapisuje vlastne meno instancie, treba referencovat uz existujucu triedu
		- opat, co ak naimportovana...?


		

[TODO]
--------------------------------------------------------------------------------------------
		

INDENTACIA ???
----------------------------------------------
- TODO
- priprava prikladov:
-- Mozno aj v kombinacii s "guards", potom ale treba indentovat
maximum1 (x : xs)
    | x > maxTail = x
    | otherwise = maxTail
    where maxTail = maximum1 xs

yesnoIf x yesResult noResult =
    if x > 100
        then yesResult
        else noResult
		
-- Vsimni si v tomto pripade uzatvorkovanie pre datovy typ "Rectangle Point Point"
surface (Rectangle (Point x1 y1) (Point x2 y2)) = 
    (abs $ x2 - x1) * (abs $ y2 - y1)
	
lengthCompare1 x y =
    (length x `compare` length y) `mappend`
    (x `compare` y)
		
-- Definicia cez viacero riadkov
b = [ [ 1, 2, 3, 4 ]
    , [ 5, 3, 3, 3 ]
    , [ 1, 2, 2, 3, 4 ]
    , [ 1, 2, 3 ]
    ]	

-- Definicia na viacero riadkov
data Shape =
      Circle    Point Float		-- Predstavuje stred kruznice a polomer
    | Rectangle Point Point		-- Predstavuje lavy horny a pravy dolny bod	
	
- where:
	f x
		| cond1 x   = a
		| cond2 x   = g a
		| otherwise = f (h x a)
		where
			a = w x
- let:
	f x
		= let a = w x in 		-- cize co znamena "a" sa uz urci tu
			case () of			-- a v ramci jakeho scopeu, akoby; () asi akoby povodny vyraz...?
			  _ | cond1 x   -> a
				| cond2 x   -> g a
				| otherwise -> f (h x a)
- ekvivalentne:
	f x
		= let a = w x in 
			if cond1 x then a
			else if cond2 x then g a
			else f (h x a)

			
			
Semanticka analyza ??
----------------------------------------------
- "expression" sa vyhodnocuje na "value"
- "expression" ma svoj staticky "type" (dedukuje sa, prip. moze urcit programator cez "::" operator)
- "variable", "constructor", "type variable", "type constructor", "type class"
- "variable" a "type variable" smu zacinat len malym pismenom, alebo podtrzitkom, ostatne z vymenovanych velkym pismenom

- Pouzitie len na typ, ktory bol naozaj instanciovany:
	yesnoif :: (YesNo y) => y -> Bool
	f :: Int -> Bool
	f i = yesnoif i
	- tu mozno odhalit, ze "f" je nespravne definovana, nakolko "f" prijima Int a hadze ho funkcii "yesnoif", ktora ale prijima iba instancie triedy "YesNo"
	
- Vstavane operatory, funkcie, ...
	("exp1", "exp2", "exp3") je to iste ako (,,) "exp1" "exp2" "exp3"
	- je nutne tym zachytit, ci je spravny pocet argumentov, ci dana funkcia skutocne prijima argumenty daneho typu a pod.



Vynechane:
----------------------------------------------

Zavinac
--------------
capital (zoznam@(x : xs)) =
    "The first letter of " ++ (packed zoznam) ++ " is " ++ (ctos x)
	
anyChoice2 ch =
	case ch of
		Nothing -> "No choice!"
		Just score@(First "gold") -> "First with gold!"
		Just score@(First _) -> "First with something else."

- poznamky:
f s@(x:xs) = x:s
Technically speaking, as-patterns always result in a successful match, although the sub-pattern (in this case x:xs) could, of course, fail.
		
		
Lazy patterns
--------------
-- Trieda "Def", ktora vracia defaultnu hodnotu; chceme rozsirit na "Maybe" triedu
instance Def a => Def (Maybe a) where
 defValue (Just x) = Just (defValue x)
 defValue Nothing = Nothing
 
-- Ten "Nothing" vsak nie je idealny a tak pouzijeme "lazy pattern"
-- Tvarime sa, ze vzdy namatchujeme "Just x" (aj ked to nie je pravda)
instance Def a => Def (Maybe a) where
 defValue ~(Just x) = Just (defValue x)
			
-- Co teda, ked niekto zavola "defValue" na "Nothing"? Musi volat tymto sposobom, inak runtime fail
defMB = defValue (Nothing :: Maybe Bool)


Record syntax
--------------
data Person = Person { firstName :: String, lastName :: String, age :: Int }
mikeD = Person { firstName = "Michael", lastName = "Diamond", age = 43 }


Monady
--------------
example1 :: IO ()
example1 = do
    a <- (++) <$> getLine <*> getLine
    putStrLn $ "The two lines concatenated turn out to be: " ++ a
	
	
	
Deriving a pod.
--------------
derive Show Point


Private, Public ...
--------------
private reduce :: Rational -> Rational


Vstavane operatory a funkcie
--------------
- niektore budu, ale iba niektore
- este nie je ujasnene


Newtype
--------------
- vo frege nie je "newtype" keyword, cize ani nebude podporovany